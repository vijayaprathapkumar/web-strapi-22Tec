{"version":3,"file":"index.mjs","sources":["../../server/src/config/default-config.ts","../../server/src/config/index.ts","../../server/src/format-graphql-error.ts","../../server/src/bootstrap.ts","../../server/src/services/content-api/policy.ts","../../server/src/services/content-api/wrap-resolvers.ts","../../server/src/services/content-api/register-functions/collection-type.ts","../../server/src/services/content-api/register-functions/single-type.ts","../../server/src/services/content-api/register-functions/component.ts","../../server/src/services/content-api/register-functions/polymorphic.ts","../../server/src/services/content-api/register-functions/scalars.ts","../../server/src/services/content-api/register-functions/internals.ts","../../server/src/services/content-api/register-functions/content-type/dynamic-zones.ts","../../server/src/services/content-api/register-functions/content-type/enums.ts","../../server/src/services/content-api/register-functions/content-type/inputs.ts","../../server/src/services/content-api/register-functions/content-type/filters.ts","../../server/src/services/content-api/register-functions/content-type/index.ts","../../server/src/services/content-api/index.ts","../../server/src/services/type-registry.ts","../../server/src/services/utils/mappers/strapi-scalar-to-graphql-scalar.ts","../../server/src/services/utils/mappers/graphql-filters-to-strapi-query.ts","../../server/src/services/utils/mappers/graphql-scalar-to-operators.ts","../../server/src/services/utils/mappers/entity-to-response-entity.ts","../../server/src/services/utils/mappers/index.ts","../../server/src/services/utils/attributes.ts","../../server/src/services/utils/naming.ts","../../server/src/services/utils/index.ts","../../server/src/services/constants.ts","../../server/src/services/internals/args/sort.ts","../../server/src/services/internals/args/publication-state.ts","../../server/src/services/internals/args/pagination.ts","../../server/src/services/internals/args/index.ts","../../server/src/services/internals/scalars/time.ts","../../server/src/services/internals/scalars/date.ts","../../server/src/services/internals/scalars/index.ts","../../server/src/services/internals/types/pagination.ts","../../server/src/services/internals/types/response-collection-meta.ts","../../server/src/services/internals/types/publication-state.ts","../../server/src/services/internals/types/filters.ts","../../server/src/services/internals/types/error.ts","../../server/src/services/internals/types/index.ts","../../server/src/services/internals/helpers/get-enabled-scalars.ts","../../server/src/services/internals/helpers/index.ts","../../server/src/services/internals/index.ts","../../server/src/services/builders/enums.ts","../../server/src/services/builders/dynamic-zones.ts","../../server/src/services/builders/entity.ts","../../server/src/services/builders/entity-meta.ts","../../server/src/services/builders/type.ts","../../server/src/services/builders/response.ts","../../server/src/services/builders/response-collection.ts","../../server/src/services/builders/relation-response-collection.ts","../../server/src/services/builders/queries/collection-type.ts","../../server/src/services/builders/queries/single-type.ts","../../server/src/services/builders/queries/index.ts","../../server/src/services/builders/mutations/collection-type.ts","../../server/src/services/builders/mutations/single-type.ts","../../server/src/services/builders/mutations/index.ts","../../server/src/services/builders/filters/content-type.ts","../../server/src/services/builders/filters/index.ts","../../server/src/services/builders/input.ts","../../server/src/services/builders/generic-morph.ts","../../server/src/services/builders/resolvers/association.ts","../../server/src/services/builders/resolvers/query.ts","../../server/src/services/builders/resolvers/mutation.ts","../../server/src/services/builders/resolvers/component.ts","../../server/src/services/builders/resolvers/dynamic-zone.ts","../../server/src/services/builders/resolvers/index.ts","../../server/src/services/builders/filters/operators/and.ts","../../server/src/services/builders/filters/operators/or.ts","../../server/src/services/builders/filters/operators/not.ts","../../server/src/services/builders/filters/operators/eq.ts","../../server/src/services/builders/filters/operators/eqi.ts","../../server/src/services/builders/filters/operators/ne.ts","../../server/src/services/builders/filters/operators/nei.ts","../../server/src/services/builders/filters/operators/starts-with.ts","../../server/src/services/builders/filters/operators/ends-with.ts","../../server/src/services/builders/filters/operators/contains.ts","../../server/src/services/builders/filters/operators/not-contains.ts","../../server/src/services/builders/filters/operators/containsi.ts","../../server/src/services/builders/filters/operators/not-containsi.ts","../../server/src/services/builders/filters/operators/gt.ts","../../server/src/services/builders/filters/operators/gte.ts","../../server/src/services/builders/filters/operators/lt.ts","../../server/src/services/builders/filters/operators/lte.ts","../../server/src/services/builders/filters/operators/null.ts","../../server/src/services/builders/filters/operators/not-null.ts","../../server/src/services/builders/filters/operators/in.ts","../../server/src/services/builders/filters/operators/not-in.ts","../../server/src/services/builders/filters/operators/between.ts","../../server/src/services/builders/filters/operators/index.ts","../../server/src/services/builders/utils.ts","../../server/src/services/builders/index.ts","../../server/src/services/extension/shadow-crud-manager.ts","../../server/src/services/extension/extension.ts","../../server/src/services/format/return-types.ts","../../server/src/services/format/index.ts","../../server/src/services/index.ts","../../server/src/index.ts"],"sourcesContent":["export default {\n  shadowCRUD: true,\n  endpoint: '/graphql',\n  subscriptions: false,\n  maxLimit: -1,\n  apolloServer: {},\n};\n","import defaultConfig from './default-config';\n\nexport const config = {\n  default: defaultConfig,\n};\n","import { toUpper, snakeCase, pick, isEmpty } from 'lodash/fp';\nimport { errors } from '@strapi/utils';\nimport {\n  ApolloError,\n  UserInputError as ApolloUserInputError,\n  ForbiddenError as ApolloForbiddenError,\n} from 'apollo-server-koa';\nimport { GraphQLError } from 'graphql';\n\nconst { HttpError, ForbiddenError, UnauthorizedError, ApplicationError, ValidationError } = errors;\n\nconst formatToCode = (name: string) => `STRAPI_${toUpper(snakeCase(name))}`;\nconst formatErrorToExtension = (error: any) => ({\n  error: pick(['name', 'message', 'details'])(error),\n});\n\nexport function formatGraphqlError(error: GraphQLError) {\n  const { originalError } = error;\n\n  if (isEmpty(originalError)) {\n    return error;\n  }\n\n  if (originalError instanceof ForbiddenError || originalError instanceof UnauthorizedError) {\n    return new ApolloForbiddenError(originalError.message, formatErrorToExtension(originalError));\n  }\n\n  if (originalError instanceof ValidationError) {\n    return new ApolloUserInputError(originalError.message, formatErrorToExtension(originalError));\n  }\n\n  if (originalError instanceof ApplicationError || originalError instanceof HttpError) {\n    const name = formatToCode(originalError.name);\n    return new ApolloError(originalError.message, name, formatErrorToExtension(originalError));\n  }\n\n  if (originalError instanceof ApolloError || originalError instanceof GraphQLError) {\n    return error;\n  }\n\n  // Internal server error\n  strapi.log.error(originalError);\n  return new ApolloError('Internal Server Error', 'INTERNAL_SERVER_ERROR');\n}\n","import { isEmpty, mergeWith, isArray } from 'lodash/fp';\nimport { ApolloServer } from 'apollo-server-koa';\nimport {\n  ApolloServerPluginLandingPageDisabled,\n  ApolloServerPluginLandingPageGraphQLPlayground,\n} from 'apollo-server-core';\nimport depthLimit from 'graphql-depth-limit';\nimport { graphqlUploadKoa } from 'graphql-upload';\nimport type { Config } from 'apollo-server-core';\nimport type { Strapi } from '@strapi/types';\n\nimport { formatGraphqlError } from './format-graphql-error';\n\nconst merge = mergeWith((a, b) => {\n  if (isArray(a) && isArray(b)) {\n    return a.concat(b);\n  }\n});\n\n/**\n * Register the upload middleware powered by graphql-upload in Strapi\n * @param {object} strapi\n * @param {string} path\n */\nconst useUploadMiddleware = (strapi: Strapi, path: string): void => {\n  const uploadMiddleware = graphqlUploadKoa();\n\n  strapi.server.app.use((ctx, next) => {\n    if (ctx.path === path) {\n      return uploadMiddleware(ctx, next);\n    }\n\n    return next();\n  });\n};\n\nexport async function bootstrap({ strapi }: { strapi: Strapi }) {\n  // Generate the GraphQL schema for the content API\n  const schema = strapi.plugin('graphql').service('content-api').buildSchema();\n\n  if (isEmpty(schema)) {\n    strapi.log.warn('The GraphQL schema has not been generated because it is empty');\n\n    return;\n  }\n\n  const { config } = strapi.plugin('graphql');\n\n  const path: string = config('endpoint');\n\n  const defaultServerConfig: Config & {\n    cors: boolean;\n    uploads: boolean;\n    bodyParserConfig: boolean;\n  } = {\n    // Schema\n    schema,\n\n    // Initialize loaders for this request.\n    context: ({ ctx }) => ({\n      state: ctx.state,\n      koaContext: ctx,\n    }),\n\n    // Validation\n    validationRules: [depthLimit(config('depthLimit') as number) as any],\n\n    // Errors\n    formatError: formatGraphqlError,\n\n    // Misc\n    cors: false,\n    uploads: false,\n    bodyParserConfig: true,\n\n    plugins: [\n      process.env.NODE_ENV === 'production' && !config('playgroundAlways')\n        ? ApolloServerPluginLandingPageDisabled()\n        : ApolloServerPluginLandingPageGraphQLPlayground(),\n    ],\n\n    cache: 'bounded' as const,\n  };\n\n  const serverConfig = merge(defaultServerConfig, config('apolloServer'));\n\n  // Create a new Apollo server\n  const server = new ApolloServer(serverConfig);\n\n  // Register the upload middleware\n  useUploadMiddleware(strapi, path);\n\n  try {\n    // Since Apollo-Server v3, server.start() must be called before using server.applyMiddleware()\n    await server.start();\n  } catch (error) {\n    if (error instanceof Error) {\n      strapi.log.error('Failed to start the Apollo server', error.message);\n    }\n\n    throw error;\n  }\n\n  // Link the Apollo server & the Strapi app\n  strapi.server.routes([\n    {\n      method: 'ALL',\n      path,\n      handler: [\n        (ctx, next) => {\n          ctx.state.route = {\n            info: {\n              // Indicate it's a content API route\n              type: 'content-api',\n            },\n          };\n\n          // allow graphql playground to load without authentication\n          if (ctx.request.method === 'GET') return next();\n\n          return strapi.auth.authenticate(ctx, next);\n        },\n\n        // Apollo Server\n        server.getMiddleware({\n          path,\n          cors: serverConfig.cors,\n          bodyParserConfig: serverConfig.bodyParserConfig,\n        }),\n      ],\n      config: {\n        auth: false,\n      },\n    },\n  ]);\n\n  // Register destroy behavior\n  // We're doing it here instead of exposing a destroy method to the strapi-server.js\n  // file since we need to have access to the ApolloServer instance\n  strapi.plugin('graphql').destroy = async () => {\n    await server.stop();\n  };\n}\n","import { propOr } from 'lodash/fp';\nimport { GraphQLFieldResolver, GraphQLResolveInfo } from 'graphql';\nimport { policy as policyUtils, errors } from '@strapi/utils';\nimport type { Strapi } from '@strapi/types';\n\nconst { PolicyError } = errors;\n\nconst getPoliciesConfig = propOr([], 'policies');\n\nconst createPoliciesMiddleware = (resolverConfig: any, { strapi }: { strapi: Strapi }) => {\n  const resolverPolicies = getPoliciesConfig(resolverConfig);\n  const policies = policyUtils.resolve(resolverPolicies, {});\n\n  return async (\n    resolve: GraphQLFieldResolver<any, any>,\n    parent: any,\n    args: any,\n    context: any,\n    info: GraphQLResolveInfo\n  ) => {\n    // Create a graphql policy context\n    const policyContext = createGraphQLPolicyContext(parent, args, context, info);\n\n    // Run policies & throw an error if one of them fails\n    for (const { handler, config } of policies) {\n      const result = await handler(policyContext, config, { strapi });\n\n      if (![true, undefined].includes(result)) {\n        throw new PolicyError();\n      }\n    }\n\n    return resolve(parent, args, context, info);\n  };\n};\n\nconst createGraphQLPolicyContext = (\n  parent: any,\n  args: any,\n  context: any,\n  info: GraphQLResolveInfo\n) => {\n  const policyContext = {\n    get parent() {\n      return parent;\n    },\n\n    get args() {\n      return args;\n    },\n\n    get context() {\n      return context;\n    },\n\n    get info() {\n      return info;\n    },\n\n    get state() {\n      return this.context.state;\n    },\n\n    get http() {\n      return this.context.koaContext;\n    },\n  };\n\n  return policyUtils.createPolicyContext('graphql', policyContext);\n};\n\nexport { createPoliciesMiddleware };\n","import { get, getOr, isFunction, first, isNil } from 'lodash/fp';\nimport {\n  GraphQLObjectType,\n  GraphQLResolveInfo,\n  GraphQLSchema,\n  GraphQLFieldResolver,\n} from 'graphql';\nimport { errors } from '@strapi/utils';\nimport type { Strapi, Common } from '@strapi/types';\n\nimport { createPoliciesMiddleware } from './policy';\n\nconst { ForbiddenError } = errors;\n\nconst introspectionQueries = [\n  '__Schema',\n  '__Type',\n  '__Field',\n  '__InputValue',\n  '__EnumValue',\n  '__Directive',\n];\n\ntype GraphQLMiddleware = (\n  resolve: GraphQLFieldResolver<any, any>,\n  parents: unknown,\n  args: unknown,\n  context: unknown,\n  info: GraphQLResolveInfo\n) => any;\n\n/**\n * Get & parse middlewares definitions from the resolver's config\n * @param {object} resolverConfig\n * @param {object} strapi\n * @return {function[]}\n */\nconst parseMiddlewares = (resolverConfig: any, strapi: Strapi): GraphQLMiddleware[] => {\n  const resolverMiddlewares = getOr([], 'middlewares', resolverConfig);\n\n  // TODO: [v4] to factorize with compose endpoints (routes)\n  return resolverMiddlewares.map(\n    (middleware: string | Common.MiddlewareHandler | { name: string; options: any }) => {\n      if (isFunction(middleware)) {\n        return middleware;\n      }\n\n      if (typeof middleware === 'string') {\n        return strapi.middleware(middleware);\n      }\n\n      if (typeof middleware === 'object') {\n        const { name, options = {} } = middleware;\n\n        return strapi.middleware(name)(options, { strapi });\n      }\n\n      throw new Error(\n        `Invalid middleware type, expected (function,string,object), received ${typeof middleware}`\n      );\n    }\n  );\n};\n\n/**\n * Wrap the schema's resolvers if they've been\n * customized using the GraphQL extension service\n * @param {object} options\n * @param {GraphQLSchema} options.schema\n * @param {object} options.strapi\n * @param {object} options.extension\n * @return {GraphQLSchema}\n */\nconst wrapResolvers = ({\n  schema,\n  strapi,\n  extension = {},\n}: {\n  schema: GraphQLSchema;\n  strapi: Strapi;\n  extension: any;\n}) => {\n  // Get all the registered resolvers configuration\n  const { resolversConfig = {} } = extension;\n\n  // Fields filters\n  const isValidFieldName = (field: string) => !field.startsWith('__');\n\n  const typeMap = schema.getTypeMap();\n\n  Object.entries(typeMap).forEach(([type, definition]) => {\n    const isGraphQLObjectType = definition instanceof GraphQLObjectType;\n    const isIgnoredType = introspectionQueries.includes(type);\n\n    if (!isGraphQLObjectType || isIgnoredType) {\n      return;\n    }\n\n    const fields = definition.getFields();\n    const fieldsToProcess = Object.entries(fields).filter(([field]) => isValidFieldName(field));\n\n    for (const [fieldName, fieldDefinition] of fieldsToProcess) {\n      const defaultResolver = get(fieldName);\n\n      const path = `${type}.${fieldName}`;\n      const resolverConfig = getOr({}, path, resolversConfig);\n\n      const { resolve: baseResolver = defaultResolver } = fieldDefinition;\n\n      // Parse & initialize the middlewares\n      const middlewares = parseMiddlewares(resolverConfig, strapi);\n\n      // Generate the policy middleware\n      const policyMiddleware = createPoliciesMiddleware(resolverConfig, { strapi });\n\n      // Add the policyMiddleware at the end of the middlewares collection\n      middlewares.push(policyMiddleware);\n\n      // Bind every middleware to the next one\n      const boundMiddlewares = middlewares.map((middleware, index, collection) => {\n        return (parents: unknown, args: unknown, context: unknown, info: GraphQLResolveInfo) =>\n          middleware(\n            // Make sure the last middleware in the list calls the baseResolver\n            index >= collection.length - 1 ? baseResolver : boundMiddlewares[index + 1],\n            parents,\n            args,\n            context,\n            info\n          );\n      });\n\n      /**\n       * GraphQL authorization flow\n       * @param {object} context\n       * @return {Promise<void>}\n       */\n      const authorize = async ({ context }: any) => {\n        const authConfig = get('auth', resolverConfig);\n        const authContext = get('state.auth', context);\n\n        const isValidType = ['Mutation', 'Query', 'Subscription'].includes(type);\n        const hasConfig = !isNil(authConfig);\n\n        const isAuthDisabled = authConfig === false;\n\n        if ((isValidType || hasConfig) && !isAuthDisabled) {\n          try {\n            await strapi.auth.verify(authContext, authConfig);\n          } catch (error) {\n            throw new ForbiddenError();\n          }\n        }\n      };\n\n      /**\n       * Base resolver wrapper that handles authorization, middlewares & policies\n       * @return {Promise<any>}\n       */\n      fieldDefinition.resolve = async (parent, args, context, info) => {\n        await authorize({ context });\n\n        // Execute middlewares (including the policy middleware which will always be included)\n        return first(boundMiddlewares)!(parent, args, context, info);\n      };\n    }\n  });\n\n  return schema;\n};\n\nexport { wrapResolvers };\n","import type { Strapi, Schema } from '@strapi/types';\nimport type { TypeRegistry } from '../../type-registry';\n\nconst registerCollectionType = (\n  contentType: Schema.CollectionType,\n  {\n    registry,\n    strapi,\n    builders,\n  }: {\n    registry: TypeRegistry;\n    strapi: Strapi;\n    builders: any;\n  }\n) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const { naming } = getService('utils');\n  const { KINDS } = getService('constants');\n\n  const extension = getService('extension');\n\n  // Types name (as string)\n  const types = {\n    base: naming.getTypeName(contentType),\n    entity: naming.getEntityName(contentType),\n    response: naming.getEntityResponseName(contentType),\n    responseCollection: naming.getEntityResponseCollectionName(contentType),\n    relationResponseCollection: naming.getRelationResponseCollectionName(contentType),\n    queries: naming.getEntityQueriesTypeName(contentType),\n    mutations: naming.getEntityMutationsTypeName(contentType),\n  };\n\n  const getConfig = (kind: string) => ({ kind, contentType });\n\n  // Type definition\n  registry.register(types.base, builders.buildTypeDefinition(contentType), getConfig(KINDS.type));\n\n  // Higher level entity definition\n  registry.register(\n    types.entity,\n    builders.buildEntityDefinition(contentType),\n    getConfig(KINDS.entity)\n  );\n\n  // Responses definition\n  registry.register(\n    types.response,\n    builders.buildResponseDefinition(contentType),\n    getConfig(KINDS.entityResponse)\n  );\n\n  registry.register(\n    types.responseCollection,\n    builders.buildResponseCollectionDefinition(contentType),\n    getConfig(KINDS.entityResponseCollection)\n  );\n\n  registry.register(\n    types.relationResponseCollection,\n    builders.buildRelationResponseCollectionDefinition(contentType),\n    getConfig(KINDS.relationResponseCollection)\n  );\n\n  if (extension.shadowCRUD(contentType.uid).areQueriesEnabled()) {\n    // Query extensions\n    registry.register(\n      types.queries,\n      builders.buildCollectionTypeQueries(contentType),\n      getConfig(KINDS.query)\n    );\n  }\n\n  if (extension.shadowCRUD(contentType.uid).areMutationsEnabled()) {\n    // Mutation extensions\n    registry.register(\n      types.mutations,\n      builders.buildCollectionTypeMutations(contentType),\n      getConfig(KINDS.mutation)\n    );\n  }\n};\n\nexport { registerCollectionType };\n","import type { Strapi, Schema } from '@strapi/types';\nimport type { TypeRegistry } from '../../type-registry';\n\nconst registerSingleType = (\n  contentType: Schema.SingleType,\n  {\n    registry,\n    strapi,\n    builders,\n  }: {\n    registry: TypeRegistry;\n    strapi: Strapi;\n    builders: any;\n  }\n) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const { naming } = getService('utils');\n  const { KINDS } = getService('constants');\n\n  const extension = getService('extension');\n\n  const types = {\n    base: naming.getTypeName(contentType),\n    entity: naming.getEntityName(contentType),\n    response: naming.getEntityResponseName(contentType),\n    responseCollection: naming.getEntityResponseCollectionName(contentType),\n    relationResponseCollection: naming.getRelationResponseCollectionName(contentType),\n    queries: naming.getEntityQueriesTypeName(contentType),\n    mutations: naming.getEntityMutationsTypeName(contentType),\n  };\n\n  const getConfig = (kind: string) => ({ kind, contentType });\n\n  // Single type's definition\n  registry.register(types.base, builders.buildTypeDefinition(contentType), getConfig(KINDS.type));\n\n  // Higher level entity definition\n  registry.register(\n    types.entity,\n    builders.buildEntityDefinition(contentType),\n    getConfig(KINDS.entity)\n  );\n\n  // Responses definition\n  registry.register(\n    types.response,\n    builders.buildResponseDefinition(contentType),\n    getConfig(KINDS.entityResponse)\n  );\n\n  // Response collection definition\n  registry.register(\n    types.responseCollection,\n    builders.buildResponseCollectionDefinition(contentType),\n    getConfig(KINDS.entityResponseCollection)\n  );\n\n  registry.register(\n    types.relationResponseCollection,\n    builders.buildRelationResponseCollectionDefinition(contentType),\n    getConfig(KINDS.relationResponseCollection)\n  );\n\n  if (extension.shadowCRUD(contentType.uid).areQueriesEnabled()) {\n    // Queries\n    registry.register(\n      types.queries,\n      builders.buildSingleTypeQueries(contentType),\n      getConfig(KINDS.query)\n    );\n  }\n\n  if (extension.shadowCRUD(contentType.uid).areMutationsEnabled()) {\n    // Mutations\n    registry.register(\n      types.mutations,\n      builders.buildSingleTypeMutations(contentType),\n      getConfig(KINDS.mutation)\n    );\n  }\n};\n\nexport { registerSingleType };\n","import type { Strapi, Schema } from '@strapi/types';\nimport type { TypeRegistry } from '../../type-registry';\n\nconst registerComponent = (\n  contentType: Schema.Component,\n  {\n    registry,\n    strapi,\n    builders,\n  }: {\n    registry: TypeRegistry;\n    strapi: Strapi;\n    builders: any;\n  }\n) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const { getComponentName } = getService('utils').naming;\n  const { KINDS } = getService('constants');\n\n  const name = getComponentName(contentType);\n  const definition = builders.buildTypeDefinition(contentType);\n\n  registry.register(name, definition, { kind: KINDS.component, contentType });\n};\n\nexport { registerComponent };\n","import { unionType } from 'nexus';\nimport type { Schema } from '@strapi/types';\nimport type { Context } from '../../types';\n\nconst registerPolymorphicContentType = (contentType: Schema.Any, { registry, strapi }: Context) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const {\n    naming,\n    attributes: { isMorphRelation },\n  } = getService('utils');\n  const { KINDS } = getService('constants');\n\n  const { attributes = {} } = contentType;\n\n  // Isolate its polymorphic attributes\n  const morphAttributes = Object.entries(attributes).filter(([, attribute]) =>\n    isMorphRelation(attribute)\n  );\n\n  // For each one of those polymorphic attribute\n  for (const [attributeName, attribute] of morphAttributes) {\n    const name = naming.getMorphRelationTypeName(contentType, attributeName);\n    const { target } = attribute as any;\n\n    // Ignore those whose target is not an array\n    if (!Array.isArray(target)) {\n      continue;\n    }\n\n    // Transform target UIDs into types names\n    const members = target\n      // Get content types definitions\n      .map((uid) => strapi.getModel(uid))\n      // Resolve types names\n      .map((contentType) => naming.getTypeName(contentType));\n\n    // Register the new polymorphic union type\n    registry.register(\n      name,\n\n      unionType({\n        name,\n\n        resolveType(obj) {\n          const contentType = strapi.getModel(obj.__type);\n\n          if (!contentType) {\n            return null;\n          }\n\n          if (contentType.modelType === 'component') {\n            return naming.getComponentName(contentType);\n          }\n\n          return naming.getTypeName(contentType);\n        },\n\n        definition(t) {\n          t.members(...members);\n        },\n      }),\n\n      { kind: KINDS.morph, contentType, attributeName }\n    );\n  }\n};\n\nexport { registerPolymorphicContentType };\n","import type { Context } from '../../types';\n\nconst registerScalars = ({ registry, strapi }: Context) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const { scalars } = getService('internals');\n  const { KINDS } = getService('constants');\n\n  Object.entries(scalars).forEach(([name, definition]) => {\n    registry.register(name, definition, { kind: KINDS.scalar });\n  });\n};\n\nexport { registerScalars };\n","import type { Context } from '../../types';\n\nconst registerInternals = ({ registry, strapi }: Context) => {\n  const { buildInternalTypes } = strapi.plugin('graphql').service('internals');\n\n  const internalTypes = buildInternalTypes({ strapi });\n\n  for (const [kind, definitions] of Object.entries(internalTypes)) {\n    registry.registerMany(Object.entries(definitions as any), { kind });\n  }\n};\n\nexport { registerInternals };\n","import type { Strapi, Schema } from '@strapi/types';\nimport type { TypeRegistry } from '../../../type-registry';\n\nconst registerDynamicZonesDefinition = (\n  contentType: Schema.Any,\n  {\n    registry,\n    strapi,\n    builders,\n  }: {\n    registry: TypeRegistry;\n    strapi: Strapi;\n    builders: any;\n  }\n) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const {\n    naming,\n    attributes: { isDynamicZone },\n  } = getService('utils');\n  const { KINDS } = getService('constants');\n\n  const { attributes } = contentType;\n\n  const dynamicZoneAttributes = Object.keys(attributes).filter((attributeName) =>\n    isDynamicZone(attributes[attributeName])\n  );\n\n  for (const attributeName of dynamicZoneAttributes) {\n    const attribute = attributes[attributeName];\n    const dzName = naming.getDynamicZoneName(contentType, attributeName);\n    const dzInputName = naming.getDynamicZoneInputName(contentType, attributeName);\n\n    const [type, input] = builders.buildDynamicZoneDefinition(attribute, dzName, dzInputName);\n\n    const baseConfig = {\n      contentType,\n      attributeName,\n      attribute,\n    };\n\n    registry.register(dzName, type, { kind: KINDS.dynamicZone, ...baseConfig });\n    registry.register(dzInputName, input, { kind: KINDS.input, ...baseConfig });\n  }\n};\n\nexport { registerDynamicZonesDefinition };\n","import type { Strapi, Schema } from '@strapi/types';\nimport type { TypeRegistry } from '../../../type-registry';\n\nconst registerEnumsDefinition = (\n  contentType: Schema.Any,\n  {\n    registry,\n    strapi,\n    builders,\n  }: {\n    registry: TypeRegistry;\n    strapi: Strapi;\n    builders: any;\n  }\n) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const {\n    naming,\n    attributes: { isEnumeration },\n  } = getService('utils');\n  const { KINDS } = getService('constants');\n\n  const { attributes } = contentType;\n\n  const enumAttributes = Object.keys(attributes).filter((attributeName) =>\n    isEnumeration(attributes[attributeName])\n  );\n\n  for (const attributeName of enumAttributes) {\n    const attribute = attributes[attributeName];\n\n    const enumName = naming.getEnumName(contentType, attributeName);\n    const enumDefinition = builders.buildEnumTypeDefinition(attribute, enumName);\n\n    registry.register(enumName, enumDefinition, {\n      kind: KINDS.enum,\n      contentType,\n      attributeName,\n      attribute,\n    });\n  }\n};\n\nexport { registerEnumsDefinition };\n","import type { Strapi, Schema } from '@strapi/types';\nimport type { TypeRegistry } from '../../../type-registry';\n\nconst registerInputsDefinition = (\n  contentType: Schema.Any,\n  {\n    registry,\n    strapi,\n    builders,\n  }: {\n    registry: TypeRegistry;\n    strapi: Strapi;\n    builders: any;\n  }\n) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const { getComponentInputName, getContentTypeInputName } = getService('utils').naming;\n  const { KINDS } = getService('constants');\n\n  const { modelType } = contentType;\n\n  const type = (modelType === 'component' ? getComponentInputName : getContentTypeInputName).call(\n    null,\n    contentType\n  );\n\n  const definition = builders.buildInputType(contentType);\n\n  registry.register(type, definition, { kind: KINDS.input, contentType });\n};\n\nexport { registerInputsDefinition };\n","import type { Strapi, Schema } from '@strapi/types';\nimport type { TypeRegistry } from '../../../type-registry';\n\nconst registerFiltersDefinition = (\n  contentType: Schema.Any,\n  {\n    registry,\n    strapi,\n    builders,\n  }: {\n    registry: TypeRegistry;\n    strapi: Strapi;\n    builders: any;\n  }\n) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const { getFiltersInputTypeName } = getService('utils').naming;\n  const { KINDS } = getService('constants');\n\n  const type = getFiltersInputTypeName(contentType);\n  const definition = builders.buildContentTypeFilters(contentType);\n\n  registry.register(type, definition, { kind: KINDS.filtersInput, contentType });\n};\n\nexport { registerFiltersDefinition };\n","import { registerDynamicZonesDefinition } from './dynamic-zones';\nimport { registerEnumsDefinition } from './enums';\nimport { registerInputsDefinition } from './inputs';\nimport { registerFiltersDefinition } from './filters';\n\nexport default {\n  registerDynamicZonesDefinition,\n  registerFiltersDefinition,\n  registerInputsDefinition,\n  registerEnumsDefinition,\n};\n","import { pruneSchema } from '@graphql-tools/utils';\nimport { makeSchema } from 'nexus';\nimport { prop, startsWith } from 'lodash/fp';\nimport type * as Nexus from 'nexus';\nimport type { Schema, Strapi } from '@strapi/types';\n\nimport { wrapResolvers } from './wrap-resolvers';\nimport {\n  registerSingleType,\n  registerCollectionType,\n  registerComponent,\n  registerScalars,\n  registerInternals,\n  registerPolymorphicContentType,\n  contentType,\n} from './register-functions';\nimport { TypeRegistry } from '../type-registry';\n\nconst {\n  registerEnumsDefinition,\n  registerInputsDefinition,\n  registerFiltersDefinition,\n  registerDynamicZonesDefinition,\n} = contentType;\n\nexport default ({ strapi }: { strapi: Strapi }) => {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const { mergeSchemas, addResolversToSchema } = require('@graphql-tools/schema');\n\n  const { service: getGraphQLService } = strapi.plugin('graphql');\n  const { config } = strapi.plugin('graphql');\n\n  const { KINDS, GENERIC_MORPH_TYPENAME } = getGraphQLService('constants');\n  const extensionService = getGraphQLService('extension');\n\n  // Type Registry\n  let registry: any;\n  // Builders Instances\n  let builders: any;\n\n  const buildSchema = () => {\n    const isShadowCRUDEnabled = !!config('shadowCRUD');\n\n    // Create a new empty type registry\n    registry = getGraphQLService('type-registry').new();\n\n    // Reset the builders instances associated to the\n    // content-api, and link the new type registry\n    builders = getGraphQLService('builders').new('content-api', registry);\n\n    registerScalars({ registry, strapi });\n    registerInternals({ registry, strapi });\n\n    if (isShadowCRUDEnabled) {\n      shadowCRUD();\n    }\n\n    // Build a merged schema from both Nexus types & SDL type definitions\n    const schema = buildMergedSchema({ registry });\n\n    // Generate the extension configuration for the content API.\n    // This extension instance needs to be generated after the Nexus schema's\n    // generation, so that configurations created during types definitions\n    // can be registered before being used in the wrap resolvers operation\n    const extension = extensionService.generate({ typeRegistry: registry });\n\n    // Add the extension's resolvers to the final schema\n    const schemaWithResolvers = addResolversToSchema(schema, extension.resolvers);\n\n    // Create a configuration object for the artifacts generation\n    const outputs: Nexus.core.SchemaConfig['outputs'] = {\n      schema: config('artifacts.schema', false),\n      typegen: config('artifacts.typegen', false),\n    };\n\n    const currentEnv = strapi.config.get('environment');\n\n    const nexusSchema = makeSchema({\n      types: [],\n      // Build the schema from the merged GraphQL schema.\n      // Since we're passing the schema to the mergeSchema property, it'll transform our SDL type definitions\n      // into Nexus type definition, thus allowing them to be handled by  Nexus plugins & other processing\n      mergeSchema: { schema: schemaWithResolvers },\n\n      // Apply user-defined plugins\n      plugins: extension.plugins,\n\n      // Whether to generate artifacts (GraphQL schema, TS types definitions) or not.\n      // By default, we generate artifacts only on development environment\n      shouldGenerateArtifacts: config('generateArtifacts', currentEnv === 'development'),\n\n      // Artifacts generation configuration\n      outputs,\n    });\n\n    // Wrap resolvers if needed (auth, middlewares, policies...) as configured in the extension\n    const wrappedNexusSchema = wrapResolvers({ schema: nexusSchema, strapi, extension });\n\n    // Prune schema, remove unused types\n    // eg: removes registered subscriptions if they're disabled in the config)\n    const prunedNexusSchema = pruneSchema(wrappedNexusSchema);\n\n    return prunedNexusSchema;\n  };\n\n  const buildMergedSchema = ({ registry }: { registry: TypeRegistry }) => {\n    // Here we extract types, plugins & typeDefs from a temporary generated\n    // extension since there won't be any addition allowed after schemas generation\n    const { types, typeDefs = [] } = extensionService.generate({ typeRegistry: registry });\n\n    // Nexus schema built with user-defined & shadow CRUD auto generated Nexus types\n    const nexusSchema = makeSchema({ types: [registry.definitions, types] });\n\n    // Merge type definitions with the Nexus schema\n    return mergeSchemas({\n      typeDefs,\n      // Give access to the shadowCRUD & nexus based types\n      // Note: This is necessary so that types defined in SDL can reference types defined with Nexus\n      schemas: [nexusSchema],\n    });\n  };\n\n  const shadowCRUD = () => {\n    const extensionService = getGraphQLService('extension');\n\n    // Get every content type & component defined in Strapi\n    const contentTypes = [\n      ...Object.values(strapi.components),\n      ...Object.values(strapi.contentTypes),\n    ];\n\n    // Disable Shadow CRUD for admin content types\n    contentTypes\n      .map(prop('uid'))\n      .filter(startsWith('admin::'))\n      .forEach((uid) => extensionService.shadowCRUD(uid).disable());\n\n    const contentTypesWithShadowCRUD = contentTypes.filter((ct) =>\n      extensionService.shadowCRUD(ct.uid).isEnabled()\n    );\n\n    // Generate and register definitions for every content type\n    registerAPITypes(contentTypesWithShadowCRUD);\n\n    // Generate and register polymorphic types' definitions\n    registerMorphTypes(contentTypesWithShadowCRUD);\n  };\n\n  /**\n   * Register needed GraphQL types for every content type\n   * @param {object[]} contentTypes\n   */\n  const registerAPITypes = (contentTypes: Schema.Any[]) => {\n    for (const contentType of contentTypes) {\n      const { modelType } = contentType;\n\n      const registerOptions = { registry, strapi, builders };\n\n      // Generate various types associated to the content type\n      // (enums, dynamic-zones, filters, inputs...)\n      registerEnumsDefinition(contentType, registerOptions);\n      registerDynamicZonesDefinition(contentType, registerOptions);\n      registerFiltersDefinition(contentType, registerOptions);\n      registerInputsDefinition(contentType, registerOptions);\n\n      // Generate & register component's definition\n      if (modelType === 'component') {\n        registerComponent(contentType, registerOptions);\n        continue;\n      }\n\n      const { kind } = contentType;\n\n      // Generate & register single type's definition\n      if (kind === 'singleType') {\n        registerSingleType(contentType, registerOptions);\n      }\n\n      // Generate & register collection type's definition\n      else if (kind === 'collectionType') {\n        registerCollectionType(contentType, registerOptions);\n      }\n    }\n  };\n\n  const registerMorphTypes = (contentTypes: Schema.Any[]) => {\n    // Create & register a union type that includes every type or component registered\n    const genericMorphType = builders.buildGenericMorphDefinition();\n    registry.register(GENERIC_MORPH_TYPENAME, genericMorphType, { kind: KINDS.morph });\n\n    for (const contentType of contentTypes) {\n      registerPolymorphicContentType(contentType, { registry, strapi });\n    }\n  };\n\n  return { buildSchema };\n};\n","import { isFunction } from 'lodash/fp';\nimport { errors } from '@strapi/utils';\n\nconst { ApplicationError } = errors;\n\nexport type TypeRegistry = {\n  register(name: string, definition: any, config?: object): TypeRegistry;\n  registerMany(\n    definitionsEntries: [string, any][],\n    config?: object | ((...args: any[]) => any)\n  ): TypeRegistry;\n  has(name: string): boolean;\n  get(name: string): any;\n  toObject(): Record<string, any>;\n  types: string[];\n  definitions: any[];\n  where(predicate: (item: any) => boolean): any[];\n};\n\n/**\n * Create a new type registry\n */\nconst createTypeRegistry = (): TypeRegistry => {\n  const registry = new Map();\n\n  const typeRegistry: TypeRegistry = {\n    /**\n     * Register a new type definition\n     */\n    register(name, definition, config = {}) {\n      if (registry.has(name)) {\n        throw new ApplicationError(`\"${name}\" has already been registered`);\n      }\n\n      registry.set(name, { name, definition, config });\n\n      return this;\n    },\n\n    /**\n     * Register many types definitions at once\n     * @param {[string, NexusAcceptedTypeDef][]} definitionsEntries\n     * @param {object | function} [config]\n     */\n    registerMany(definitionsEntries, config = {}) {\n      for (const [name, definition] of definitionsEntries) {\n        this.register(name, definition, isFunction(config) ? config(name, definition) : config);\n      }\n\n      return this;\n    },\n\n    /**\n     * Check if the given type name has already been added to the registry\n     * @param {string} name\n     * @return {boolean}\n     */\n    has(name) {\n      return registry.has(name);\n    },\n\n    /**\n     * Get the type definition for `name`\n     * @param {string} name - The name of the type\n     */\n    get(name) {\n      return registry.get(name);\n    },\n\n    /**\n     * Transform and return the registry as an object\n     * @return {Object<string, RegisteredTypeDef>}\n     */\n    toObject() {\n      return Object.fromEntries(registry.entries());\n    },\n\n    /**\n     * Return the name of every registered type\n     * @return {string[]}\n     */\n    get types() {\n      return Array.from(registry.keys());\n    },\n\n    /**\n     * Return all the registered definitions as an array\n     * @return {RegisteredTypeDef[]}\n     */\n    get definitions() {\n      return Array.from(registry.values());\n    },\n\n    /**\n     * Filter and return the types definitions that matches the given predicate\n     * @param {function(RegisteredTypeDef): boolean} predicate\n     * @return {RegisteredTypeDef[]}\n     */\n    where(predicate) {\n      return this.definitions.filter(predicate);\n    },\n  };\n\n  return typeRegistry;\n};\n\nexport default () => ({\n  new: createTypeRegistry,\n});\n","import { get, difference } from 'lodash/fp';\nimport { errors } from '@strapi/utils';\nimport type { Context } from '../../types';\n\nconst { ApplicationError } = errors;\n\nexport default ({ strapi }: Context) => {\n  const { STRAPI_SCALARS, SCALARS_ASSOCIATIONS } = strapi.plugin('graphql').service('constants');\n\n  const missingStrapiScalars = difference(STRAPI_SCALARS, Object.keys(SCALARS_ASSOCIATIONS));\n\n  if (missingStrapiScalars.length > 0) {\n    throw new ApplicationError('Some Strapi scalars are not handled in the GraphQL scalars mapper');\n  }\n\n  return {\n    /**\n     * Used to transform a Strapi scalar type into its GraphQL equivalent\n     */\n    strapiScalarToGraphQLScalar(strapiScalar: string) {\n      return get(strapiScalar, SCALARS_ASSOCIATIONS);\n    },\n  };\n};\n","import { has, propEq, isNil, isDate, isObject } from 'lodash/fp';\nimport type { Schema } from '@strapi/types';\nimport type { Context } from '../../types';\n\n// todo[v4]: Find a way to get that dynamically\nconst virtualScalarAttributes = ['id'];\n\nexport default ({ strapi }: Context) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const recursivelyReplaceScalarOperators = (data: any): any => {\n    const { operators } = getService('builders').filters;\n\n    if (Array.isArray(data)) {\n      return data.map(recursivelyReplaceScalarOperators);\n    }\n\n    // Note: We need to make an exception for date since GraphQL\n    // automatically cast date strings to date instances in args\n    if (isDate(data) || !isObject(data)) {\n      return data;\n    }\n\n    const result: any = {};\n\n    for (const [key, value] of Object.entries(data)) {\n      const isOperator = !!operators[key];\n\n      const newKey = isOperator ? operators[key].strapiOperator : key;\n\n      result[newKey] = recursivelyReplaceScalarOperators(value);\n    }\n\n    return result;\n  };\n\n  return {\n    /**\n     * Transform one or many GraphQL filters object into a valid Strapi query\n     * @param {object | object[]} filters\n     * @param {object} contentType\n     * @return {object | object[]}\n     */\n    graphQLFiltersToStrapiQuery(filters: any, contentType: Schema.Any): any {\n      const { isStrapiScalar, isMedia, isRelation, isComponent } = getService('utils').attributes;\n      const { operators } = getService('builders').filters;\n\n      const ROOT_LEVEL_OPERATORS = [operators.and, operators.or, operators.not];\n\n      // Handle unwanted scenario where there is no filters defined\n      if (isNil(filters)) {\n        return {};\n      }\n\n      // If filters is a collection, then apply the transformation to every item of the list\n      if (Array.isArray(filters)) {\n        return filters.map((filtersItem) =>\n          this.graphQLFiltersToStrapiQuery(filtersItem, contentType)\n        );\n      }\n\n      const resultMap: any = {};\n      const { attributes } = contentType;\n\n      const isAttribute = (attributeName: string) => {\n        return virtualScalarAttributes.includes(attributeName) || has(attributeName, attributes);\n      };\n\n      for (const [key, value] of Object.entries(filters)) {\n        // If the key is an attribute, update the value\n        if (isAttribute(key)) {\n          const attribute: any = attributes[key];\n\n          // If it's a scalar attribute\n          if (virtualScalarAttributes.includes(key) || isStrapiScalar(attribute)) {\n            // Replace (recursively) every GraphQL scalar operator with the associated Strapi operator\n            resultMap[key] = recursivelyReplaceScalarOperators(value);\n          }\n\n          // If it's a deep filter on a relation\n          else if (isRelation(attribute) || isMedia(attribute)) {\n            // Fetch the model from the relation\n            const relModel = strapi.getModel(attribute.target);\n\n            // Recursively apply the mapping to the value using the fetched model,\n            // and update the value within `resultMap`\n            resultMap[key] = this.graphQLFiltersToStrapiQuery(value, relModel);\n          }\n\n          // If it's a deep filter on a component\n          else if (isComponent(attribute)) {\n            // Fetch the model from the component attribute\n            const componentModel = strapi.getModel(attribute.component);\n\n            // Recursively apply the mapping to the value using the fetched model,\n            // and update the value within `resultMap`\n            resultMap[key] = this.graphQLFiltersToStrapiQuery(value, componentModel);\n          }\n        }\n\n        // Handle the case where the key is not an attribute (operator, ...)\n        else {\n          const rootLevelOperator = ROOT_LEVEL_OPERATORS.find(propEq('fieldName', key));\n\n          // If it's a root level operator (AND, NOT, OR, ...)\n          if (rootLevelOperator) {\n            const { strapiOperator } = rootLevelOperator;\n\n            // Transform the current value recursively and add it to the resultMap\n            // object using the strapiOperator equivalent of the GraphQL key\n            resultMap[strapiOperator] = this.graphQLFiltersToStrapiQuery(value, contentType);\n          }\n        }\n      }\n\n      return resultMap;\n    },\n  };\n};\n","import { get, map, mapValues } from 'lodash/fp';\nimport type { Context } from '../../types';\n\nexport default ({ strapi }: Context) => ({\n  graphqlScalarToOperators(graphqlScalar: string) {\n    const { GRAPHQL_SCALAR_OPERATORS } = strapi.plugin('graphql').service('constants');\n    const { operators } = strapi.plugin('graphql').service('builders').filters;\n\n    const associations = mapValues(\n      map((operatorName: string) => operators[operatorName]),\n      GRAPHQL_SCALAR_OPERATORS\n    );\n\n    return get(graphqlScalar, associations);\n  },\n});\n","import { map } from 'lodash/fp';\nimport type { Entity } from '@strapi/types';\n\nconst entityToResponseEntity = (entity: { id: Entity.ID; [key: keyof any]: unknown }) => ({\n  id: entity.id,\n  attributes: entity,\n});\n\nconst entitiesToResponseEntities = map(entityToResponseEntity);\n\nexport default () => ({\n  entityToResponseEntity,\n  entitiesToResponseEntities,\n});\n","import strapiScalarToGraphQLScalar from './strapi-scalar-to-graphql-scalar';\nimport graphQLFiltersToStrapiQuery from './graphql-filters-to-strapi-query';\nimport graphqlScalarToOperators from './graphql-scalar-to-operators';\nimport entityToResponseEntity from './entity-to-response-entity';\n\nimport type { Context } from '../../types';\n\nexport default (context: Context) => ({\n  ...strapiScalarToGraphQLScalar(context),\n  ...graphQLFiltersToStrapiQuery(context),\n  ...graphqlScalarToOperators(context),\n  ...entityToResponseEntity(),\n});\n","import { propEq } from 'lodash/fp';\nimport type { Attribute } from '@strapi/types';\nimport type { Context } from '../types';\n\nexport default ({ strapi }: Context) => {\n  /**\n   * Check if the given attribute is a Strapi scalar\n   * @param {object} attribute\n   * @return {boolean}\n   */\n  const isStrapiScalar = (attribute: Attribute.Any) => {\n    return strapi.plugin('graphql').service('constants').STRAPI_SCALARS.includes(attribute.type);\n  };\n\n  /**\n   * Check if the given attribute is a GraphQL scalar\n   * @param {object} attribute\n   * @return {boolean}\n   */\n  const isGraphQLScalar = (attribute: Attribute.Any) => {\n    return strapi.plugin('graphql').service('constants').GRAPHQL_SCALARS.includes(attribute.type);\n  };\n\n  /**\n   * Check if the given attribute is a polymorphic relation\n   * @param {object} attribute\n   * @return {boolean}\n   */\n  const isMorphRelation = (attribute: Attribute.Any) => {\n    return attribute.type === 'relation' && attribute.relation.includes('morph');\n  };\n\n  /**\n   * Check if the given attribute is a media\n   * @param {object} attribute\n   * @return {boolean}\n   */\n  const isMedia = propEq('type', 'media');\n\n  /**\n   * Check if the given attribute is a relation\n   * @param {object} attribute\n   * @return {boolean}\n   */\n  const isRelation = propEq('type', 'relation');\n\n  /**\n   * Check if the given attribute is an enum\n   * @param {object} attribute\n   * @return {boolean}\n   */\n  const isEnumeration = propEq('type', 'enumeration');\n\n  /**\n   * Check if the given attribute is a component\n   * @param {object} attribute\n   * @return {boolean}\n   */\n  const isComponent = propEq('type', 'component');\n\n  /**\n   * Check if the given attribute is a dynamic zone\n   * @param {object} attribute\n   * @return {boolean}\n   */\n  const isDynamicZone = propEq('type', 'dynamiczone');\n\n  return {\n    isStrapiScalar,\n    isGraphQLScalar,\n    isMorphRelation,\n    isMedia,\n    isRelation,\n    isEnumeration,\n    isComponent,\n    isDynamicZone,\n  };\n};\n","import { camelCase, upperFirst, lowerFirst, pipe, get } from 'lodash/fp';\nimport { singular } from 'pluralize';\nimport { errors } from '@strapi/utils';\nimport type { Attribute, Schema } from '@strapi/types';\nimport type { Context } from '../types';\n\nconst { ApplicationError } = errors;\n\nexport default ({ strapi }: Context) => {\n  /**\n   * Build a type name for a enum based on a content type & an attribute name\n   */\n  const getEnumName = (contentType: Schema.Any, attributeName: string) => {\n    const { attributes } = contentType;\n    const { enumName } = attributes[attributeName] as Attribute.Enumeration;\n    const { modelType } = contentType;\n\n    const typeName =\n      modelType === 'component' ? getComponentName(contentType) : getTypeName(contentType);\n\n    const defaultEnumName = `ENUM_${typeName.toUpperCase()}_${attributeName.toUpperCase()}`;\n\n    return enumName || defaultEnumName;\n  };\n\n  /**\n   * Build the base type name for a given content type\n   */\n  const getTypeName = (\n    contentType: Schema.Any,\n    {\n      plurality = 'singular',\n    }: {\n      plurality?: 'singular' | 'plural';\n    } = {}\n  ) => {\n    const plugin = get('plugin', contentType);\n    const modelName = get('modelName', contentType);\n    const name =\n      plurality === 'singular'\n        ? get('info.singularName', contentType)\n        : get('info.pluralName', contentType);\n\n    const transformedPlugin = upperFirst(camelCase(plugin));\n    const transformedModelName = upperFirst(camelCase(name || singular(modelName)));\n\n    return `${transformedPlugin}${transformedModelName}`;\n  };\n\n  /**\n   * Build the entity's type name for a given content type\n   */\n  const getEntityName = (contentType: Schema.Any) => {\n    return `${getTypeName(contentType)}Entity`;\n  };\n\n  /**\n   * Build the entity meta type name for a given content type\n   */\n  const getEntityMetaName = (contentType: Schema.Any) => {\n    return `${getEntityName(contentType)}Meta`;\n  };\n\n  /**\n   * Build the entity response's type name for a given content type\n   */\n  const getEntityResponseName = (contentType: Schema.Any) => {\n    return `${getEntityName(contentType)}Response`;\n  };\n\n  /**\n   * Build the entity response collection's type name for a given content type\n   */\n  const getEntityResponseCollectionName = (contentType: Schema.Any) => {\n    return `${getEntityName(contentType)}ResponseCollection`;\n  };\n\n  /**\n   * Build the relation response collection's type name for a given content type\n   */\n  const getRelationResponseCollectionName = (contentType: Schema.Any) => {\n    return `${getTypeName(contentType)}RelationResponseCollection`;\n  };\n\n  /**\n   * Build a component type name based on its definition\n   */\n  const getComponentName = (contentType: Schema.Any) => {\n    return contentType.globalId;\n  };\n\n  /**\n   * Build a component type name based on a content type's attribute\n   */\n  const getComponentNameFromAttribute = (attribute: Attribute.Component) => {\n    return strapi.components[attribute.component].globalId;\n  };\n\n  /**\n   * Build a dynamic zone type name based on a content type and an attribute name\n   */\n  const getDynamicZoneName = (contentType: Schema.Any, attributeName: string) => {\n    const typeName = getTypeName(contentType);\n    const dzName = upperFirst(camelCase(attributeName));\n    const suffix = 'DynamicZone';\n\n    return `${typeName}${dzName}${suffix}`;\n  };\n\n  /**\n   * Build a dynamic zone input type name based on a content type and an attribute name\n   */\n  const getDynamicZoneInputName = (contentType: Schema.Any, attributeName: string) => {\n    const dzName = getDynamicZoneName(contentType, attributeName);\n\n    return `${dzName}Input`;\n  };\n\n  /**\n   * Build a component input type name based on a content type and an attribute name\n   */\n  const getComponentInputName = (contentType: Schema.Any) => {\n    const componentName = getComponentName(contentType);\n\n    return `${componentName}Input`;\n  };\n\n  /**\n   * Build a content type input name based on a content type and an attribute name\n   */\n  const getContentTypeInputName = (contentType: Schema.Any) => {\n    const typeName = getTypeName(contentType);\n\n    return `${typeName}Input`;\n  };\n\n  /**\n   * Build the queries type name for a given content type\n   */\n  const getEntityQueriesTypeName = (contentType: Schema.Any) => {\n    return `${getEntityName(contentType)}Queries`;\n  };\n\n  /**\n   * Build the mutations type name for a given content type\n   */\n  const getEntityMutationsTypeName = (contentType: Schema.Any) => {\n    return `${getEntityName(contentType)}Mutations`;\n  };\n\n  /**\n   * Build the filters type name for a given content type\n   */\n  const getFiltersInputTypeName = (contentType: Schema.Any) => {\n    const isComponent = contentType.modelType === 'component';\n\n    const baseName = isComponent ? getComponentName(contentType) : getTypeName(contentType);\n\n    return `${baseName}FiltersInput`;\n  };\n\n  /**\n   * Build a filters type name for a given GraphQL scalar type\n   */\n  const getScalarFilterInputTypeName = (scalarType: string) => {\n    return `${scalarType}FilterInput`;\n  };\n\n  /**\n   * Build a type name for a given content type & polymorphic attribute\n   */\n  const getMorphRelationTypeName = (contentType: Schema.Any, attributeName: string) => {\n    const typeName = getTypeName(contentType);\n    const formattedAttr = upperFirst(camelCase(attributeName));\n\n    return `${typeName}${formattedAttr}Morph`;\n  };\n\n  /**\n   * Build a custom type name generator with different customization options\n   */\n  const buildCustomTypeNameGenerator = (options: {\n    prefix?: string;\n    suffix?: string;\n    firstLetterCase?: 'upper' | 'lower';\n    plurality?: 'plural' | 'singular';\n  }) => {\n    // todo[v4]: use singularName & pluralName is available\n    const { prefix = '', suffix = '', plurality = 'singular', firstLetterCase = 'upper' } = options;\n\n    if (!['plural', 'singular'].includes(plurality)) {\n      throw new ApplicationError(\n        `\"plurality\" param must be either \"plural\" or \"singular\", but got: \"${plurality}\"`\n      );\n    }\n\n    const getCustomTypeName = pipe(\n      (ct) => getTypeName(ct, { plurality }),\n      firstLetterCase === 'upper' ? upperFirst : lowerFirst\n    );\n\n    return (contentType: Schema.Any) => `${prefix}${getCustomTypeName(contentType)}${suffix}`;\n  };\n\n  const getFindQueryName = buildCustomTypeNameGenerator({\n    plurality: 'plural',\n    firstLetterCase: 'lower',\n  });\n\n  const getFindOneQueryName = buildCustomTypeNameGenerator({ firstLetterCase: 'lower' });\n\n  const getCreateMutationTypeName = buildCustomTypeNameGenerator({\n    prefix: 'create',\n    firstLetterCase: 'upper',\n  });\n\n  const getUpdateMutationTypeName = buildCustomTypeNameGenerator({\n    prefix: 'update',\n    firstLetterCase: 'upper',\n  });\n\n  const getDeleteMutationTypeName = buildCustomTypeNameGenerator({\n    prefix: 'delete',\n    firstLetterCase: 'upper',\n  });\n\n  return {\n    getEnumName,\n    getTypeName,\n    getEntityName,\n    getEntityMetaName,\n    getEntityResponseName,\n    getEntityResponseCollectionName,\n    getRelationResponseCollectionName,\n    getComponentName,\n    getComponentNameFromAttribute,\n    getDynamicZoneName,\n    getDynamicZoneInputName,\n    getComponentInputName,\n    getContentTypeInputName,\n    getEntityQueriesTypeName,\n    getEntityMutationsTypeName,\n    getFiltersInputTypeName,\n    getScalarFilterInputTypeName,\n    getMorphRelationTypeName,\n    buildCustomTypeNameGenerator,\n    getFindQueryName,\n    getFindOneQueryName,\n    getCreateMutationTypeName,\n    getUpdateMutationTypeName,\n    getDeleteMutationTypeName,\n  };\n};\n","import mappers from './mappers';\nimport attributes from './attributes';\nimport naming from './naming';\n\nimport type { Context } from '../types';\n\nexport default (context: Context) => ({\n  naming: naming(context),\n  attributes: attributes(context),\n  mappers: mappers(context),\n});\n","const PAGINATION_TYPE_NAME = 'Pagination';\nconst PUBLICATION_STATE_TYPE_NAME = 'PublicationState';\nconst ERROR_TYPE_NAME = 'Error';\n\nconst RESPONSE_COLLECTION_META_TYPE_NAME = 'ResponseCollectionMeta';\n\nconst GRAPHQL_SCALARS = [\n  'ID',\n  'Boolean',\n  'Int',\n  'String',\n  'Long',\n  'Float',\n  'JSON',\n  'Date',\n  'Time',\n  'DateTime',\n] as const;\n\nconst STRAPI_SCALARS = [\n  'boolean',\n  'integer',\n  'string',\n  'richtext',\n  'blocks',\n  'enumeration',\n  'biginteger',\n  'float',\n  'decimal',\n  'json',\n  'date',\n  'time',\n  'datetime',\n  'timestamp',\n  'uid',\n  'email',\n  'password',\n  'text',\n] as const;\n\nconst SCALARS_ASSOCIATIONS = {\n  uid: 'String',\n  email: 'String',\n  password: 'String',\n  text: 'String',\n  boolean: 'Boolean',\n  integer: 'Int',\n  string: 'String',\n  enumeration: 'String',\n  richtext: 'String',\n  blocks: 'JSON',\n  biginteger: 'Long',\n  float: 'Float',\n  decimal: 'Float',\n  json: 'JSON',\n  date: 'Date',\n  time: 'Time',\n  datetime: 'DateTime',\n  timestamp: 'DateTime',\n} as const;\n\nconst GENERIC_MORPH_TYPENAME = 'GenericMorph';\n\nconst KINDS = {\n  type: 'type',\n  component: 'component',\n  dynamicZone: 'dynamic-zone',\n  enum: 'enum',\n  entity: 'entity',\n  entityResponse: 'entity-response',\n  entityResponseCollection: 'entity-response-collection',\n  relationResponseCollection: 'relation-response-collection',\n  query: 'query',\n  mutation: 'mutation',\n  input: 'input',\n  filtersInput: 'filters-input',\n  scalar: 'scalar',\n  morph: 'polymorphic',\n  internal: 'internal',\n} as const;\n\nconst allOperators = [\n  'and',\n  'or',\n  'not',\n\n  'eq',\n  'eqi',\n  'ne',\n  'nei',\n\n  'startsWith',\n  'endsWith',\n\n  'contains',\n  'notContains',\n\n  'containsi',\n  'notContainsi',\n\n  'gt',\n  'gte',\n\n  'lt',\n  'lte',\n\n  'null',\n  'notNull',\n\n  'in',\n  'notIn',\n\n  'between',\n] as const;\n\nconst GRAPHQL_SCALAR_OPERATORS = {\n  // ID\n  ID: allOperators,\n  // Booleans\n  Boolean: allOperators,\n  // Strings\n  String: allOperators,\n  // Numbers\n  Int: allOperators,\n  Long: allOperators,\n  Float: allOperators,\n  // Dates\n  Date: allOperators,\n  Time: allOperators,\n  DateTime: allOperators,\n  // Others\n  JSON: allOperators,\n} as const;\n\nconst ERROR_CODES = {\n  emptyDynamicZone: 'dynamiczone.empty',\n} as const;\n\nexport type Constants = {\n  PAGINATION_TYPE_NAME: string;\n  RESPONSE_COLLECTION_META_TYPE_NAME: string;\n  PUBLICATION_STATE_TYPE_NAME: string;\n  GRAPHQL_SCALARS: string[];\n  STRAPI_SCALARS: string[];\n  GENERIC_MORPH_TYPENAME: string;\n  KINDS: typeof KINDS;\n  GRAPHQL_SCALAR_OPERATORS: typeof GRAPHQL_SCALAR_OPERATORS;\n  SCALARS_ASSOCIATIONS: typeof SCALARS_ASSOCIATIONS;\n  ERROR_CODES: typeof ERROR_CODES;\n  ERROR_TYPE_NAME: string;\n};\n\nexport default () => ({\n  PAGINATION_TYPE_NAME,\n  RESPONSE_COLLECTION_META_TYPE_NAME,\n  PUBLICATION_STATE_TYPE_NAME,\n  GRAPHQL_SCALARS,\n  STRAPI_SCALARS,\n  GENERIC_MORPH_TYPENAME,\n  KINDS,\n  GRAPHQL_SCALAR_OPERATORS,\n  SCALARS_ASSOCIATIONS,\n  ERROR_CODES,\n  ERROR_TYPE_NAME,\n});\n","import { arg, list } from 'nexus';\n\nconst SortArg = arg({\n  type: list('String'),\n  default: [],\n});\n\nexport default SortArg;\n","import { arg } from 'nexus';\nimport { Context } from '../../types';\n\nexport default ({ strapi }: Context) => {\n  const { PUBLICATION_STATE_TYPE_NAME } = strapi.plugin('graphql').service('constants');\n\n  return arg({\n    type: PUBLICATION_STATE_TYPE_NAME,\n    default: 'live',\n  });\n};\n","import { arg, inputObjectType } from 'nexus';\n\nconst PaginationInputType = inputObjectType({\n  name: 'PaginationArg',\n\n  definition(t) {\n    t.int('page');\n    t.int('pageSize');\n    t.int('start');\n    t.int('limit');\n  },\n});\n\nexport default arg({\n  type: PaginationInputType,\n  default: {},\n});\n","import SortArg from './sort';\nimport publicationState from './publication-state';\nimport PaginationArg from './pagination';\nimport type { Context } from '../../types';\n\nexport default (context: Context) => ({\n  SortArg,\n  PaginationArg,\n  PublicationStateArg: publicationState(context),\n});\n","import { GraphQLScalarType, Kind } from 'graphql';\nimport { parseType, errors } from '@strapi/utils';\n\nconst { ValidationError } = errors;\n\n/**\n * A GraphQL scalar used to store Time (HH:mm:ss.SSS) values\n * @type {GraphQLScalarType}\n */\nconst TimeScalar = new GraphQLScalarType({\n  name: 'Time',\n\n  description: 'A time string with format HH:mm:ss.SSS',\n\n  serialize(value) {\n    return parseType({ type: 'time', value });\n  },\n\n  parseValue(value) {\n    return parseType({ type: 'time', value });\n  },\n\n  parseLiteral(ast) {\n    if (ast.kind !== Kind.STRING) {\n      throw new ValidationError('Time cannot represent non string type');\n    }\n\n    const { value } = ast;\n\n    return parseType({ type: 'time', value });\n  },\n});\n\nexport default TimeScalar;\n","import { GraphQLDate } from 'graphql-scalars';\n\nconst parseAndCast =\n  (parseFn: any) =>\n  (...args: any[]) => {\n    const parsedValue = parseFn(...args);\n\n    if (parsedValue instanceof Date) {\n      return parsedValue.toISOString().split('T')[0];\n    }\n\n    return parsedValue;\n  };\n\n// GraphQLDate casts the date string to new Date, we want to keep it as a string so we cast it back to a string\n// see https://github.com/excitement-engineer/graphql-iso-date/issues/106\nGraphQLDate.parseValue = parseAndCast(GraphQLDate.parseValue);\nGraphQLDate.parseLiteral = parseAndCast(GraphQLDate.parseLiteral);\n\nexport default GraphQLDate;\n","import { GraphQLDateTime, GraphQLLong, GraphQLJSON } from 'graphql-scalars';\nimport { GraphQLUpload } from 'graphql-upload';\nimport { asNexusMethod } from 'nexus';\n\nimport TimeScalar from './time';\nimport GraphQLDate from './date';\n\nexport default () => ({\n  JSON: asNexusMethod(GraphQLJSON, 'json'),\n  DateTime: asNexusMethod(GraphQLDateTime, 'dateTime'),\n  Time: asNexusMethod(TimeScalar, 'time'),\n  Date: asNexusMethod(GraphQLDate, 'date'),\n  Long: asNexusMethod(GraphQLLong, 'long'),\n  Upload: asNexusMethod(GraphQLUpload as any, 'upload'),\n});\n","import { objectType } from 'nexus';\nimport type { Context } from '../../types';\n\nexport default ({ strapi }: Context) => {\n  const { PAGINATION_TYPE_NAME } = strapi.plugin('graphql').service('constants');\n\n  return {\n    /**\n     * Type definition for a Pagination object\n     * @type {NexusObjectTypeDef}\n     */\n    Pagination: objectType({\n      name: PAGINATION_TYPE_NAME,\n\n      definition(t) {\n        t.nonNull.int('total');\n        t.nonNull.int('page');\n        t.nonNull.int('pageSize');\n        t.nonNull.int('pageCount');\n      },\n    }),\n  };\n};\n","import { objectType } from 'nexus';\nimport { sanitize, validate } from '@strapi/utils';\nimport type { Context } from '../../types';\n\nexport default ({ strapi }: Context) => {\n  const { RESPONSE_COLLECTION_META_TYPE_NAME, PAGINATION_TYPE_NAME } = strapi\n    .plugin('graphql')\n    .service('constants');\n\n  return {\n    /**\n     * A shared type definition used in EntitiesResponseCollection\n     * to have information about the collection as a whole\n     * @type {NexusObjectTypeDef}\n     */\n    ResponseCollectionMeta: objectType({\n      name: RESPONSE_COLLECTION_META_TYPE_NAME,\n\n      definition(t) {\n        t.nonNull.field('pagination', {\n          type: PAGINATION_TYPE_NAME,\n\n          async resolve(parent, _childArgs, ctx) {\n            const { args, resourceUID } = parent;\n            const { start, limit } = args;\n            const safeLimit = Math.max(limit, 1);\n            const contentType = strapi.getModel(resourceUID);\n            await validate.contentAPI.query(args, contentType, {\n              auth: ctx?.state?.auth,\n            });\n            const sanitizedQuery = await sanitize.contentAPI.query(args, contentType, {\n              auth: ctx?.state?.auth,\n            });\n            const total = await strapi.entityService!.count(resourceUID, sanitizedQuery);\n            const pageSize = limit === -1 ? total - start : safeLimit;\n            const pageCount = limit === -1 ? safeLimit : Math.ceil(total / safeLimit);\n            const page = limit === -1 ? safeLimit : Math.floor(start / safeLimit) + 1;\n\n            return { total, page, pageSize, pageCount };\n          },\n        });\n      },\n    }),\n  };\n};\n","import { enumType } from 'nexus';\n\nimport type { Context } from '../../types';\n\nexport default ({ strapi }: Context) => {\n  const { PUBLICATION_STATE_TYPE_NAME } = strapi.plugin('graphql').service('constants');\n\n  return {\n    /**\n     * An enum type definition representing a publication state\n     * @type {NexusEnumTypeDef}\n     */\n    PublicationState: enumType({\n      name: PUBLICATION_STATE_TYPE_NAME,\n\n      members: {\n        // Published only\n        LIVE: 'live',\n        // Published & draft\n        PREVIEW: 'preview',\n      },\n    }),\n  };\n};\n","import { inputObjectType } from 'nexus';\nimport type { Context } from '../../types';\n\n/**\n * Build a map of filters type for every GraphQL scalars\n * @return {Object<string, NexusInputTypeDef>}\n */\nconst buildScalarFilters = ({ strapi }: Context) => {\n  const { naming, mappers } = strapi.plugin('graphql').service('utils');\n  const { helpers } = strapi.plugin('graphql').service('internals');\n\n  return helpers.getEnabledScalars().reduce((acc: any, type: string) => {\n    const operators = mappers.graphqlScalarToOperators(type);\n    const typeName = naming.getScalarFilterInputTypeName(type);\n\n    if (!operators || operators.length === 0) {\n      return acc;\n    }\n\n    return {\n      ...acc,\n\n      [typeName]: inputObjectType({\n        name: typeName,\n\n        definition(t) {\n          for (const operator of operators) {\n            operator.add(t, type);\n          }\n        },\n      }),\n    };\n  }, {});\n};\n\nexport default (context: Context) => ({\n  scalars: buildScalarFilters(context),\n});\n","import { objectType } from 'nexus';\nimport { get } from 'lodash/fp';\nimport { errors } from '@strapi/utils';\n\nimport type { Context } from '../../types';\n\nconst { ValidationError } = errors;\n\n/**\n * Build an Error object type\n * @return {Object<string, NexusObjectTypeDef>}\n */\nexport default ({ strapi }: Context) => {\n  const { ERROR_CODES, ERROR_TYPE_NAME } = strapi.plugin('graphql').service('constants');\n\n  return objectType({\n    name: ERROR_TYPE_NAME,\n\n    definition(t) {\n      t.nonNull.string('code', {\n        resolve(parent) {\n          const code = get('code', parent);\n\n          const isValidPlaceholderCode = Object.values(ERROR_CODES).includes(code);\n          if (!isValidPlaceholderCode) {\n            throw new ValidationError(`\"${code}\" is not a valid code value`);\n          }\n\n          return code;\n        },\n      });\n\n      t.string('message');\n    },\n  });\n};\n","import pagination from './pagination';\nimport buildResponseCollectionMeta from './response-collection-meta';\nimport publicationState from './publication-state';\nimport filters from './filters';\nimport error from './error';\nimport type { Context } from '../../types';\n\nexport default (context: Context) => () => {\n  const { strapi } = context;\n\n  const { KINDS } = strapi.plugin('graphql').service('constants');\n\n  return {\n    [KINDS.internal]: {\n      error: error(context),\n      pagination: pagination(context),\n      responseCollectionMeta: buildResponseCollectionMeta(context),\n    },\n\n    [KINDS.enum]: {\n      publicationState: publicationState(context),\n    },\n\n    [KINDS.filtersInput]: {\n      ...filters(context),\n    },\n  };\n};\n","import { first } from 'lodash/fp';\nimport type { Context } from '../../types';\nimport type { Constants } from '../../constants';\n\nexport default ({ strapi }: Context) =>\n  () => {\n    const { GRAPHQL_SCALAR_OPERATORS } = strapi.plugin('graphql').service<Constants>('constants');\n\n    return (\n      Object.entries(GRAPHQL_SCALAR_OPERATORS)\n        // To be valid, a GraphQL scalar must have at least one operator enabled\n        .filter(([, value]) => value.length > 0)\n        // Only keep the key (the scalar name)\n        .map(first)\n    );\n  };\n","import getEnabledScalars from './get-enabled-scalars';\nimport type { Context } from '../../types';\n\nexport default (context: Context) => ({\n  getEnabledScalars: getEnabledScalars(context),\n});\n","import args from './args';\nimport scalars from './scalars';\nimport types from './types';\nimport helpers from './helpers';\nimport type { Context } from '../types';\n\nexport default (context: Context) => ({\n  args: args(context),\n  scalars: scalars(),\n  buildInternalTypes: types(context),\n  helpers: helpers(context),\n});\n","import { enumType } from 'nexus';\nimport { set } from 'lodash/fp';\nimport { toRegressedEnumValue } from '@strapi/utils';\n\ninterface Definition {\n  enum: string[];\n}\n\n/**\n * Build a Nexus enum type from a Strapi enum attribute\n * @param {object} definition - The definition of the enum\n * @param {string[]} definition.enum - The params of the enum\n * @param {string} name - The name of the enum\n * @return {NexusEnumTypeDef}\n */\nconst buildEnumTypeDefinition = (definition: Definition, name: string) => {\n  return enumType({\n    name,\n    members: definition.enum.reduce(\n      (acc, value) => set(toRegressedEnumValue(value), value, acc),\n      {}\n    ),\n  });\n};\n\nexport default () => ({\n  buildEnumTypeDefinition,\n});\n","import { Kind, valueFromASTUntyped } from 'graphql';\nimport { omit } from 'lodash/fp';\nimport { unionType, scalarType } from 'nexus';\nimport { errors } from '@strapi/utils';\nimport type { UID, Attribute } from '@strapi/types';\n\nimport type { Context } from '../types';\n\nconst { ApplicationError } = errors;\n\nexport default ({ strapi }: Context) => {\n  const buildTypeDefinition = (name: string, components: UID.Component[]) => {\n    const { ERROR_TYPE_NAME } = strapi.plugin('graphql').service('constants');\n    const isEmpty = components.length === 0;\n\n    const componentsTypeNames = components.map((componentUID) => {\n      const component = strapi.components[componentUID];\n\n      if (!component) {\n        throw new ApplicationError(\n          `Trying to create a dynamic zone type with an unknown component: \"${componentUID}\"`\n        );\n      }\n\n      return component.globalId;\n    });\n\n    return unionType({\n      name,\n\n      resolveType(obj) {\n        if (isEmpty) {\n          return ERROR_TYPE_NAME;\n        }\n\n        return strapi.components[obj.__component].globalId;\n      },\n\n      definition(t) {\n        t.members(...componentsTypeNames, ERROR_TYPE_NAME);\n      },\n    });\n  };\n\n  const buildInputDefinition = (name: string, components: UID.Component[]) => {\n    const parseData = (value: any) => {\n      const component = Object.values(strapi.components).find(\n        (component) => component.globalId === value.__typename\n      );\n\n      if (!component) {\n        throw new ApplicationError(\n          `Component not found. expected one of: ${components\n            .map((uid) => strapi.components[uid].globalId)\n            .join(', ')}`\n        );\n      }\n\n      return {\n        __component: component.uid,\n        ...omit(['__typename'], value),\n      };\n    };\n\n    return scalarType({\n      name,\n\n      serialize: (value) => value,\n\n      parseValue: (value) => parseData(value),\n\n      parseLiteral(ast, variables) {\n        if (ast.kind !== Kind.OBJECT) {\n          return undefined;\n        }\n\n        const value = valueFromASTUntyped(ast, variables);\n        return parseData(value);\n      },\n    });\n  };\n\n  return {\n    /**\n     * Build a Nexus dynamic zone type from a Strapi dz attribute\n     * @param {object} definition - The definition of the dynamic zone\n     * @param {string} name - the name of the dynamic zone\n     * @param {string} inputName - the name of the dynamic zone's input\n     * @return {[NexusUnionTypeDef, NexusScalarTypeDef]}\n     */\n    buildDynamicZoneDefinition(definition: Attribute.DynamicZone, name: string, inputName: string) {\n      const { components } = definition;\n\n      const typeDefinition = buildTypeDefinition(name, components);\n      const inputDefinition = buildInputDefinition(inputName, components);\n\n      return [typeDefinition, inputDefinition];\n    },\n  };\n};\n","import { objectType } from 'nexus';\nimport { prop, identity, isEmpty } from 'lodash/fp';\nimport type { Schema } from '@strapi/types';\n\nimport type { Context } from '../types';\n\nexport default ({ strapi }: Context) => {\n  const { naming } = strapi.plugin('graphql').service('utils');\n\n  return {\n    /**\n     * Build a higher level type for a content type which contains the attributes, the ID and the metadata\n     * @param {object} contentType The content type which will be used to build its entity type\n     * @return {NexusObjectTypeDef}\n     */\n    buildEntityDefinition(contentType: Schema.ContentType) {\n      const { attributes } = contentType;\n\n      const name = naming.getEntityName(contentType);\n      const typeName = naming.getTypeName(contentType);\n\n      return objectType({\n        name,\n\n        definition(t) {\n          // Keep the ID attribute at the top level\n          t.id('id', { resolve: prop('id') });\n\n          if (!isEmpty(attributes)) {\n            // Keep the fetched object into a dedicated `attributes` field\n            // TODO: [v4] precise why we keep the ID\n            t.field('attributes', {\n              type: typeName,\n              resolve: identity,\n            });\n          }\n\n          // todo[v4]: add the meta field to the entity when there will be data in it (can't add an empty type for now)\n          // t.field('meta', { type: utils.getEntityMetaName(contentType) });\n        },\n      });\n    },\n  };\n};\n","function buildEntityMetaDefinition(/* contentType */) {}\n\nexport default () => ({\n  buildEntityMetaDefinition,\n});\n","import { isArray, isString, isUndefined, constant } from 'lodash/fp';\nimport { objectType } from 'nexus';\nimport { contentTypes } from '@strapi/utils';\nimport type { Schema } from '@strapi/types';\n\nimport type { Context } from '../types';\n\nexport type TypeBuildersOptions = {\n  builder: any;\n  attributeName: string;\n  attribute: any;\n  contentType: any;\n  context: Context;\n};\n\nexport default (context: Context) => {\n  const { strapi } = context;\n  const getGraphQLService = strapi.plugin('graphql').service;\n\n  const extension = getGraphQLService('extension');\n\n  /**\n   * Add a scalar attribute to the type definition\n   *\n   * The attribute is added based on a simple association between a Strapi\n   * type and a GraphQL type (the map is defined in `strapiTypeToGraphQLScalar`)\n   */\n  const addScalarAttribute = (options: TypeBuildersOptions) => {\n    const { builder, attributeName, attribute } = options;\n\n    const { mappers } = getGraphQLService('utils');\n\n    const gqlType = mappers.strapiScalarToGraphQLScalar(attribute.type);\n\n    builder.field(attributeName, { type: gqlType });\n  };\n\n  /**\n   * Add a component attribute to the type definition\n   *\n   * The attribute is added by fetching the component's type\n   * name and using it as the attribute's type\n   */\n  const addComponentAttribute = (options: TypeBuildersOptions) => {\n    const { builder, attributeName, contentType, attribute } = options;\n\n    let localBuilder = builder;\n\n    const { naming } = getGraphQLService('utils');\n    const { getContentTypeArgs } = getGraphQLService('builders').utils;\n    const { buildComponentResolver } = getGraphQLService('builders').get('content-api');\n\n    const type = naming.getComponentNameFromAttribute(attribute);\n\n    if (attribute.repeatable) {\n      localBuilder = localBuilder.list;\n    }\n\n    const targetComponent = strapi.getModel(attribute.component);\n\n    const resolve = buildComponentResolver({\n      contentTypeUID: contentType.uid,\n      attributeName,\n      strapi,\n    });\n\n    const args = getContentTypeArgs(targetComponent, { multiple: !!attribute.repeatable });\n\n    localBuilder.field(attributeName, { type, resolve, args });\n  };\n\n  /**\n   * Add a dynamic zone attribute to the type definition\n   *\n   * The attribute is added by fetching the dynamic zone's\n   * type name and using it as the attribute's type\n   */\n  const addDynamicZoneAttribute = (options: TypeBuildersOptions) => {\n    const { builder, attributeName, contentType } = options;\n\n    const { naming } = getGraphQLService('utils');\n    const { ERROR_CODES } = getGraphQLService('constants');\n    const { buildDynamicZoneResolver } = getGraphQLService('builders').get('content-api');\n\n    const { components } = contentType.attributes[attributeName];\n\n    const isEmpty = components.length === 0;\n    const type = naming.getDynamicZoneName(contentType, attributeName);\n\n    const resolve = isEmpty\n      ? // If the dynamic zone don't have any component, then return an error payload\n        constant({\n          code: ERROR_CODES.emptyDynamicZone,\n          message: `This dynamic zone don't have any component attached to it`,\n        })\n      : //  Else, return a classic dynamic-zone resolver\n        buildDynamicZoneResolver({\n          contentTypeUID: contentType.uid,\n          attributeName,\n        });\n\n    builder.list.field(attributeName, { type, resolve });\n  };\n\n  /**\n   * Add an enum attribute to the type definition\n   *\n   * The attribute is added by fetching the enum's type\n   * name and using it as the attribute's type\n   */\n  const addEnumAttribute = (options: TypeBuildersOptions) => {\n    const { builder, attributeName, contentType } = options;\n\n    const { naming } = getGraphQLService('utils');\n\n    const type = naming.getEnumName(contentType, attributeName);\n\n    builder.field(attributeName, { type });\n  };\n\n  /**\n   * Add a media attribute to the type definition\n   */\n  const addMediaAttribute = (options: TypeBuildersOptions) => {\n    const { naming } = getGraphQLService('utils');\n    const { getContentTypeArgs } = getGraphQLService('builders').utils;\n    const { buildAssociationResolver } = getGraphQLService('builders').get('content-api');\n    const extension = getGraphQLService('extension');\n\n    const { builder } = options;\n    const { attributeName, attribute, contentType } = options;\n    const fileUID = 'plugin::upload.file';\n\n    if (extension.shadowCRUD(fileUID).isDisabled()) {\n      return;\n    }\n\n    const fileContentType = strapi.contentTypes[fileUID];\n\n    const resolve = buildAssociationResolver({\n      contentTypeUID: contentType.uid,\n      attributeName,\n      strapi,\n    });\n\n    const args = attribute.multiple ? getContentTypeArgs(fileContentType) : undefined;\n    const type = attribute.multiple\n      ? naming.getRelationResponseCollectionName(fileContentType)\n      : naming.getEntityResponseName(fileContentType);\n\n    builder.field(attributeName, { type, resolve, args });\n  };\n\n  /**\n   * Add a polymorphic relational attribute to the type definition\n   */\n  const addPolymorphicRelationalAttribute = (options: TypeBuildersOptions) => {\n    const { GENERIC_MORPH_TYPENAME } = getGraphQLService('constants');\n    const { naming } = getGraphQLService('utils');\n    const { buildAssociationResolver } = getGraphQLService('builders').get('content-api');\n\n    let { builder } = options;\n    const { attributeName, attribute, contentType } = options;\n\n    const { target } = attribute;\n    const isToManyRelation = attribute.relation.endsWith('Many');\n\n    if (isToManyRelation) {\n      builder = builder.list;\n    }\n    // todo[v4]: How to handle polymorphic relation w/ entity response collection types?\n    //  -> Currently return raw polymorphic entities\n\n    const resolve = buildAssociationResolver({\n      contentTypeUID: contentType.uid,\n      attributeName,\n      strapi,\n    });\n\n    // If there is no specific target specified, then use the GenericMorph type\n    if (isUndefined(target)) {\n      builder.field(attributeName, {\n        type: GENERIC_MORPH_TYPENAME,\n        resolve,\n      });\n    }\n\n    // If the target is an array of string, resolve the associated morph type and use it\n    else if (isArray(target) && target.every(isString)) {\n      const type = naming.getMorphRelationTypeName(contentType, attributeName);\n\n      builder.field(attributeName, { type, resolve });\n    }\n  };\n\n  /**\n   * Add a regular relational attribute to the type definition\n   */\n  const addRegularRelationalAttribute = (options: TypeBuildersOptions) => {\n    const { naming } = getGraphQLService('utils');\n    const { getContentTypeArgs } = getGraphQLService('builders').utils;\n    const { buildAssociationResolver } = getGraphQLService('builders').get('content-api');\n    const extension = getGraphQLService('extension');\n\n    const { builder } = options;\n    const { attributeName, attribute, contentType } = options;\n\n    if (extension.shadowCRUD(attribute.target).isDisabled()) {\n      return;\n    }\n\n    const isToManyRelation = attribute.relation.endsWith('Many');\n\n    const resolve = buildAssociationResolver({\n      contentTypeUID: contentType.uid,\n      attributeName,\n      strapi,\n    });\n\n    const targetContentType = strapi.getModel(attribute.target);\n\n    const type = isToManyRelation\n      ? naming.getRelationResponseCollectionName(targetContentType)\n      : naming.getEntityResponseName(targetContentType);\n\n    const args = isToManyRelation ? getContentTypeArgs(targetContentType) : undefined;\n\n    const resolverPath = `${naming.getTypeName(contentType)}.${attributeName}`;\n    const resolverScope = `${targetContentType.uid}.find`;\n\n    extension.use({ resolversConfig: { [resolverPath]: { auth: { scope: [resolverScope] } } } });\n\n    builder.field(attributeName, { type, resolve, args });\n  };\n\n  const isNotPrivate = (contentType: Schema.Any) => (attributeName: string) => {\n    return !contentTypes.isPrivateAttribute(contentType, attributeName);\n  };\n\n  const isNotDisabled = (contentType: Schema.Any) => (attributeName: string) => {\n    return extension.shadowCRUD(contentType.uid).field(attributeName).hasOutputEnabled();\n  };\n\n  return {\n    /**\n     * Create a type definition for a given content type\n     * @param contentType - The content type used to created the definition\n     * @return {NexusObjectTypeDef}\n     */\n    buildTypeDefinition(contentType: Schema.Any) {\n      const utils = getGraphQLService('utils');\n\n      const { getComponentName, getTypeName } = utils.naming;\n      const {\n        isStrapiScalar,\n        isComponent,\n        isDynamicZone,\n        isEnumeration,\n        isMedia,\n        isMorphRelation,\n        isRelation,\n      } = utils.attributes;\n\n      const { attributes, modelType } = contentType;\n\n      const attributesKey = Object.keys(attributes);\n\n      const name = (modelType === 'component' ? getComponentName : getTypeName).call(\n        null,\n        contentType\n      );\n\n      return objectType({\n        name,\n\n        definition(t) {\n          if (modelType === 'component' && isNotDisabled(contentType)('id')) {\n            t.nonNull.id('id');\n          }\n\n          /** Attributes\n           *\n           * Attributes can be of 7 different kind:\n           * - Scalar\n           * - Component\n           * - Dynamic Zone\n           * - Enum\n           * - Media\n           * - Polymorphic Relations\n           * - Regular Relations\n           *\n           * Here, we iterate over each non-private attribute\n           * and add it to the type definition based on its type\n           */\n          attributesKey\n            // Ignore private attributes\n            .filter(isNotPrivate(contentType))\n            // Ignore disabled fields (from extension service)\n            .filter(isNotDisabled(contentType))\n            // Add each attribute to the type definition\n            .forEach((attributeName) => {\n              const attribute = attributes[attributeName];\n\n              // We create a copy of the builder (t) to apply custom\n              // rules only on the current attribute (eg: nonNull, list, ...)\n              let builder: any = t;\n\n              if (attribute.required) {\n                builder = builder.nonNull;\n              }\n\n              const options: TypeBuildersOptions = {\n                builder,\n                attributeName,\n                attribute,\n                contentType,\n                context,\n              };\n\n              // Enums\n              if (isEnumeration(attribute)) {\n                addEnumAttribute(options);\n              }\n\n              // Scalars\n              else if (isStrapiScalar(attribute)) {\n                addScalarAttribute(options);\n              }\n\n              // Components\n              else if (isComponent(attribute)) {\n                addComponentAttribute(options);\n              }\n\n              // Dynamic Zones\n              else if (isDynamicZone(attribute)) {\n                addDynamicZoneAttribute(options);\n              }\n\n              // Media\n              else if (isMedia(attribute)) {\n                addMediaAttribute(options);\n              }\n\n              // Polymorphic Relations\n              else if (isMorphRelation(attribute)) {\n                addPolymorphicRelationalAttribute(options);\n              }\n\n              // Regular Relations\n              else if (isRelation(attribute)) {\n                addRegularRelationalAttribute(options);\n              }\n            });\n        },\n      });\n    },\n  };\n};\n","import { objectType } from 'nexus';\nimport { prop } from 'lodash/fp';\nimport type { Schema } from '@strapi/types';\nimport type { Context } from '../types';\n\nexport default ({ strapi }: Context) => {\n  const { naming } = strapi.plugin('graphql').service('utils');\n\n  return {\n    /**\n     * Build a type definition for a content API response for a given content type\n     */\n    buildResponseDefinition(contentType: Schema.ContentType) {\n      const name = naming.getEntityResponseName(contentType);\n      const entityName = naming.getEntityName(contentType);\n\n      return objectType({\n        name,\n\n        definition(t) {\n          t.field('data', {\n            type: entityName,\n\n            resolve: prop('value'),\n          });\n        },\n      });\n    },\n  };\n};\n","import { objectType, nonNull } from 'nexus';\nimport { defaultTo, prop, pipe } from 'lodash/fp';\nimport type { Schema } from '@strapi/types';\nimport type { Context } from '../types';\n\nexport default ({ strapi }: Context) => {\n  const { naming } = strapi.plugin('graphql').service('utils');\n  const { RESPONSE_COLLECTION_META_TYPE_NAME } = strapi.plugin('graphql').service('constants');\n\n  return {\n    /**\n     * Build a type definition for a content API collection response for a given content type\n     * @param {Schema.ContentType} contentType The content type which will be used to build its content API response definition\n     * @return {NexusObjectTypeDef}\n     */\n    buildResponseCollectionDefinition(contentType: Schema.ContentType) {\n      const name = naming.getEntityResponseCollectionName(contentType);\n      const entityName = naming.getEntityName(contentType);\n\n      return objectType({\n        name,\n\n        definition(t) {\n          t.nonNull.list.field('data', {\n            type: nonNull(entityName),\n\n            resolve: pipe(prop('nodes'), defaultTo([])),\n          });\n\n          t.nonNull.field('meta', {\n            type: RESPONSE_COLLECTION_META_TYPE_NAME,\n\n            // Pass down the args stored in the source object\n            resolve: prop('info'),\n          });\n        },\n      });\n    },\n  };\n};\n","import { objectType, nonNull } from 'nexus';\nimport { defaultTo, prop, pipe } from 'lodash/fp';\nimport type { Schema } from '@strapi/types';\nimport type { Context } from '../types';\n\nexport default ({ strapi }: Context) => {\n  const { naming } = strapi.plugin('graphql').service('utils');\n\n  return {\n    /**\n     * Build a type definition for a content API relation's collection response for a given content type\n     */\n    buildRelationResponseCollectionDefinition(contentType: Schema.ContentType) {\n      const name = naming.getRelationResponseCollectionName(contentType);\n      const entityName = naming.getEntityName(contentType);\n\n      return objectType({\n        name,\n\n        definition(t) {\n          t.nonNull.list.field('data', {\n            type: nonNull(entityName),\n\n            resolve: pipe(prop('nodes'), defaultTo([])),\n          });\n        },\n      });\n    },\n  };\n};\n","import { extendType } from 'nexus';\nimport type * as Nexus from 'nexus';\nimport type { Schema } from '@strapi/types';\nimport type { Context } from '../../types';\n\nexport default ({ strapi }: Context) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const { naming } = getService('utils');\n  const { transformArgs, getContentTypeArgs } = getService('builders').utils;\n  const { toEntityResponse, toEntityResponseCollection } = getService('format').returnTypes;\n\n  const {\n    getFindOneQueryName,\n    getEntityResponseName,\n    getFindQueryName,\n    getEntityResponseCollectionName,\n  } = naming;\n\n  const buildCollectionTypeQueries = (contentType: Schema.CollectionType) => {\n    const findOneQueryName = `Query.${getFindOneQueryName(contentType)}`;\n    const findQueryName = `Query.${getFindQueryName(contentType)}`;\n\n    const extension = getService('extension');\n\n    const registerAuthConfig = (action: string, auth: any) => {\n      return extension.use({ resolversConfig: { [action]: { auth } } });\n    };\n\n    const isActionEnabled = (action: string) => {\n      return extension.shadowCRUD(contentType.uid).isActionEnabled(action);\n    };\n\n    const isFindOneEnabled = isActionEnabled('findOne');\n    const isFindEnabled = isActionEnabled('find');\n\n    if (isFindOneEnabled) {\n      registerAuthConfig(findOneQueryName, { scope: [`${contentType.uid}.findOne`] });\n    }\n\n    if (isFindEnabled) {\n      registerAuthConfig(findQueryName, { scope: [`${contentType.uid}.find`] });\n    }\n\n    return extendType({\n      type: 'Query',\n\n      definition(t) {\n        if (isFindOneEnabled) {\n          addFindOneQuery(t, contentType);\n        }\n\n        if (isFindEnabled) {\n          addFindQuery(t, contentType);\n        }\n      },\n    });\n  };\n\n  /**\n   * Register a \"find one\" query field to the nexus type definition\n   */\n  const addFindOneQuery = (\n    t: Nexus.blocks.ObjectDefinitionBlock<'Query'>,\n    contentType: Schema.CollectionType\n  ) => {\n    const { uid } = contentType;\n\n    const findOneQueryName = getFindOneQueryName(contentType);\n    const responseTypeName = getEntityResponseName(contentType);\n\n    t.field(findOneQueryName, {\n      type: responseTypeName,\n\n      args: getContentTypeArgs(contentType, { multiple: false }),\n\n      async resolve(parent, args, ctx) {\n        const transformedArgs = transformArgs(args, { contentType });\n\n        const { findOne } = getService('builders')\n          .get('content-api')\n          .buildQueriesResolvers({ contentType });\n\n        // queryResolvers will sanitize params\n        const value = findOne(parent, transformedArgs, ctx);\n\n        return toEntityResponse(value, { args: transformedArgs, resourceUID: uid });\n      },\n    });\n  };\n\n  /**\n   * Register a \"find\" query field to the nexus type definition\n   */\n  const addFindQuery = (\n    t: Nexus.blocks.ObjectDefinitionBlock<'Query'>,\n    contentType: Schema.CollectionType\n  ) => {\n    const { uid } = contentType;\n\n    const findQueryName = getFindQueryName(contentType);\n    const responseCollectionTypeName = getEntityResponseCollectionName(contentType);\n\n    t.field(findQueryName, {\n      type: responseCollectionTypeName,\n\n      args: getContentTypeArgs(contentType),\n\n      async resolve(parent, args, ctx) {\n        const transformedArgs = transformArgs(args, { contentType, usePagination: true });\n\n        const { find } = getService('builders')\n          .get('content-api')\n          .buildQueriesResolvers({ contentType });\n\n        // queryResolvers will sanitize params\n        const nodes = await find(parent, transformedArgs, ctx);\n\n        return toEntityResponseCollection(nodes, { args: transformedArgs, resourceUID: uid });\n      },\n    });\n  };\n\n  return { buildCollectionTypeQueries };\n};\n","import { extendType } from 'nexus';\nimport type * as Nexus from 'nexus';\nimport type { Schema } from '@strapi/types';\nimport type { Context } from '../../types';\n\nexport default ({ strapi }: Context) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const { naming } = getService('utils');\n  const { transformArgs, getContentTypeArgs } = getService('builders').utils;\n  const { toEntityResponse } = getService('format').returnTypes;\n\n  const { getFindOneQueryName, getEntityResponseName } = naming;\n\n  const buildSingleTypeQueries = (contentType: Schema.SingleType) => {\n    const findQueryName = `Query.${getFindOneQueryName(contentType)}`;\n\n    const extension = getService('extension');\n\n    const registerAuthConfig = (action: string, auth: any) => {\n      return extension.use({ resolversConfig: { [action]: { auth } } });\n    };\n\n    const isActionEnabled = (action: string) => {\n      return extension.shadowCRUD(contentType.uid).isActionEnabled(action);\n    };\n\n    const isFindEnabled = isActionEnabled('find');\n\n    if (isFindEnabled) {\n      registerAuthConfig(findQueryName, { scope: [`${contentType.uid}.find`] });\n    }\n\n    return extendType({\n      type: 'Query',\n\n      definition(t) {\n        if (isFindEnabled) {\n          addFindQuery(t, contentType);\n        }\n      },\n    });\n  };\n\n  const addFindQuery = (\n    t: Nexus.blocks.ObjectDefinitionBlock<string>,\n    contentType: Schema.SingleType\n  ) => {\n    const { uid } = contentType;\n\n    const findQueryName = getFindOneQueryName(contentType);\n    const responseTypeName = getEntityResponseName(contentType);\n\n    t.field(findQueryName, {\n      type: responseTypeName,\n\n      args: getContentTypeArgs(contentType),\n\n      async resolve(parent, args, ctx) {\n        const transformedArgs = transformArgs(args, { contentType });\n\n        const queriesResolvers = getService('builders')\n          .get('content-api')\n          .buildQueriesResolvers({ contentType });\n\n        // queryResolvers will sanitize params\n        const value = queriesResolvers.find(parent, transformedArgs, ctx);\n\n        return toEntityResponse(value, { args: transformedArgs, resourceUID: uid });\n      },\n    });\n  };\n\n  return { buildSingleTypeQueries };\n};\n","import createCollectionTypeQueriesBuilder from './collection-type';\nimport createSingleTypeQueriesBuilder from './single-type';\nimport type { Context } from '../../types';\n\nexport default (context: Context) => ({\n  ...createCollectionTypeQueriesBuilder(context),\n  ...createSingleTypeQueriesBuilder(context),\n});\n","import { extendType, nonNull } from 'nexus';\nimport { sanitize } from '@strapi/utils';\nimport type * as Nexus from 'nexus';\nimport type { Schema } from '@strapi/types';\nimport type { Context } from '../../types';\n\nexport default ({ strapi }: Context) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const { naming } = getService('utils');\n  const { transformArgs } = getService('builders').utils;\n  const { toEntityResponse } = getService('format').returnTypes;\n\n  const {\n    getCreateMutationTypeName,\n    getUpdateMutationTypeName,\n    getDeleteMutationTypeName,\n    getEntityResponseName,\n    getContentTypeInputName,\n  } = naming;\n\n  const addCreateMutation = (\n    t: Nexus.blocks.ObjectDefinitionBlock<'Mutation'>,\n    contentType: Schema.CollectionType\n  ) => {\n    const { uid } = contentType;\n\n    const createMutationName = getCreateMutationTypeName(contentType);\n    const responseTypeName = getEntityResponseName(contentType);\n\n    t.field(createMutationName, {\n      type: responseTypeName,\n\n      args: {\n        // Create payload\n        data: nonNull(getContentTypeInputName(contentType)),\n      },\n\n      async resolve(parent, args, context) {\n        const { auth } = context.state;\n        const transformedArgs = transformArgs(args, { contentType });\n\n        // Sanitize input data\n        const sanitizedInputData = await sanitize.contentAPI.input(\n          transformedArgs.data,\n          contentType,\n          { auth }\n        );\n\n        Object.assign(transformedArgs, { data: sanitizedInputData });\n\n        const { create } = getService('builders')\n          .get('content-api')\n          .buildMutationsResolvers({ contentType });\n\n        const value = await create(parent, transformedArgs);\n\n        return toEntityResponse(value, { args: transformedArgs, resourceUID: uid });\n      },\n    });\n  };\n\n  const addUpdateMutation = (\n    t: Nexus.blocks.ObjectDefinitionBlock<'Mutation'>,\n    contentType: Schema.CollectionType\n  ) => {\n    const { uid } = contentType;\n\n    const updateMutationName = getUpdateMutationTypeName(contentType);\n    const responseTypeName = getEntityResponseName(contentType);\n\n    // todo[v4]: Don't allow to filter using every unique attributes for now\n    // Only authorize filtering using unique scalar fields for updateOne queries\n    // const uniqueAttributes = getUniqueAttributesFiltersMap(attributes);\n\n    t.field(updateMutationName, {\n      type: responseTypeName,\n\n      args: {\n        // Query args\n        id: nonNull('ID'),\n        // todo[v4]: Don't allow to filter using every unique attributes for now\n        // ...uniqueAttributes,\n\n        // Update payload\n        data: nonNull(getContentTypeInputName(contentType)),\n      },\n\n      async resolve(parent, args, context) {\n        const { auth } = context.state;\n        const transformedArgs = transformArgs(args, { contentType });\n\n        // Sanitize input data\n        const sanitizedInputData = await sanitize.contentAPI.input(\n          transformedArgs.data,\n          contentType,\n          { auth }\n        );\n\n        Object.assign(transformedArgs, { data: sanitizedInputData });\n\n        const { update } = getService('builders')\n          .get('content-api')\n          .buildMutationsResolvers({ contentType });\n\n        const value = await update(parent, transformedArgs);\n\n        return toEntityResponse(value, { args: transformedArgs, resourceUID: uid });\n      },\n    });\n  };\n\n  const addDeleteMutation = (\n    t: Nexus.blocks.ObjectDefinitionBlock<'Mutation'>,\n    contentType: Schema.CollectionType\n  ) => {\n    const { uid } = contentType;\n\n    const deleteMutationName = getDeleteMutationTypeName(contentType);\n    const responseTypeName = getEntityResponseName(contentType);\n\n    // todo[v4]: Don't allow to filter using every unique attributes for now\n    // Only authorize filtering using unique scalar fields for updateOne queries\n    // const uniqueAttributes = getUniqueAttributesFiltersMap(attributes);\n\n    t.field(deleteMutationName, {\n      type: responseTypeName,\n\n      args: {\n        // Query args\n        id: nonNull('ID'),\n        // todo[v4]: Don't allow to filter using every unique attributes for now\n        // ...uniqueAttributes,\n      },\n\n      async resolve(parent, args, ctx) {\n        const transformedArgs = transformArgs(args, { contentType });\n\n        const { delete: deleteResolver } = getService('builders')\n          .get('content-api')\n          .buildMutationsResolvers({ contentType });\n\n        const value = await deleteResolver(parent, args, ctx);\n\n        return toEntityResponse(value, { args: transformedArgs, resourceUID: uid });\n      },\n    });\n  };\n\n  return {\n    buildCollectionTypeMutations(contentType: Schema.CollectionType) {\n      const createMutationName = `Mutation.${getCreateMutationTypeName(contentType)}`;\n      const updateMutationName = `Mutation.${getUpdateMutationTypeName(contentType)}`;\n      const deleteMutationName = `Mutation.${getDeleteMutationTypeName(contentType)}`;\n\n      const extension = getService('extension');\n\n      const registerAuthConfig = (action: string, auth: any) => {\n        return extension.use({ resolversConfig: { [action]: { auth } } });\n      };\n\n      const isActionEnabled = (action: string) => {\n        return extension.shadowCRUD(contentType.uid).isActionEnabled(action);\n      };\n\n      const isCreateEnabled = isActionEnabled('create');\n      const isUpdateEnabled = isActionEnabled('update');\n      const isDeleteEnabled = isActionEnabled('delete');\n\n      if (isCreateEnabled) {\n        registerAuthConfig(createMutationName, { scope: [`${contentType.uid}.create`] });\n      }\n\n      if (isUpdateEnabled) {\n        registerAuthConfig(updateMutationName, { scope: [`${contentType.uid}.update`] });\n      }\n\n      if (isDeleteEnabled) {\n        registerAuthConfig(deleteMutationName, { scope: [`${contentType.uid}.delete`] });\n      }\n\n      return extendType({\n        type: 'Mutation',\n\n        definition(t) {\n          if (isCreateEnabled) {\n            addCreateMutation(t, contentType);\n          }\n\n          if (isUpdateEnabled) {\n            addUpdateMutation(t, contentType);\n          }\n\n          if (isDeleteEnabled) {\n            addDeleteMutation(t, contentType);\n          }\n        },\n      });\n    },\n  };\n};\n","import { extendType, nonNull } from 'nexus';\nimport { omit, isNil } from 'lodash/fp';\nimport { sanitize, validate, errors } from '@strapi/utils';\nimport type * as Nexus from 'nexus';\nimport type { Schema } from '@strapi/types';\nimport type { Context } from '../../types';\n\nconst { NotFoundError } = errors;\n\nexport default ({ strapi }: Context) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const { naming } = getService('utils');\n  const { transformArgs } = getService('builders').utils;\n  const { toEntityResponse } = getService('format').returnTypes;\n\n  const {\n    getUpdateMutationTypeName,\n    getEntityResponseName,\n    getContentTypeInputName,\n    getDeleteMutationTypeName,\n  } = naming;\n\n  const addUpdateMutation = (\n    t: Nexus.blocks.ObjectDefinitionBlock<'Mutation'>,\n    contentType: Schema.SingleType\n  ) => {\n    const { uid } = contentType;\n\n    const updateMutationName = getUpdateMutationTypeName(contentType);\n    const responseTypeName = getEntityResponseName(contentType);\n\n    t.field(updateMutationName, {\n      type: responseTypeName,\n\n      args: {\n        // Update payload\n        data: nonNull(getContentTypeInputName(contentType)),\n      },\n\n      async resolve(parent, args, context) {\n        const { auth } = context.state;\n        const transformedArgs = transformArgs(args, { contentType });\n\n        // Sanitize input data\n        const sanitizedInputData = await sanitize.contentAPI.input(\n          transformedArgs.data,\n          contentType,\n          { auth }\n        );\n\n        Object.assign(transformedArgs, { data: sanitizedInputData });\n\n        const { create, update } = getService('builders')\n          .get('content-api')\n          .buildMutationsResolvers({ contentType });\n\n        // For single types, the validation and sanitization of args is done here instead of being\n        // delegated to the query builders since we're calling the entity service directly\n\n        await validate.contentAPI.query(omit(['data', 'files'], transformedArgs), contentType, {\n          auth,\n        });\n\n        const sanitizedQuery = await sanitize.contentAPI.query(\n          omit(['data', 'files'], transformedArgs),\n          contentType,\n          {\n            auth,\n          }\n        );\n\n        const entity = (await strapi.entityService!.findMany(uid, sanitizedQuery)) as any;\n\n        // Create or update\n        const value = isNil(entity)\n          ? create(parent, transformedArgs)\n          : update(uid, { id: entity.id, data: transformedArgs.data });\n\n        return toEntityResponse(value, { args: transformedArgs, resourceUID: uid });\n      },\n    });\n  };\n\n  const addDeleteMutation = (\n    t: Nexus.blocks.ObjectDefinitionBlock<'Mutation'>,\n    contentType: Schema.SingleType\n  ) => {\n    const { uid } = contentType;\n\n    const deleteMutationName = getDeleteMutationTypeName(contentType);\n    const responseTypeName = getEntityResponseName(contentType);\n\n    t.field(deleteMutationName, {\n      type: responseTypeName,\n\n      args: {},\n\n      async resolve(parent, args, ctx) {\n        const transformedArgs = transformArgs(args, { contentType });\n\n        const { delete: deleteResolver } = getService('builders')\n          .get('content-api')\n          .buildMutationsResolvers({ contentType });\n\n        // For single types, the validation and sanitization of args is done here instead of being\n        // delegated to the query builders since we're calling the entity service directly\n\n        await validate.contentAPI.query(transformedArgs, contentType, { auth: ctx?.state?.auth });\n\n        const sanitizedQuery = await sanitize.contentAPI.query(transformedArgs, contentType, {\n          auth: ctx?.state?.auth,\n        });\n\n        const entity = (await strapi.entityService!.findMany(uid, sanitizedQuery)) as any;\n\n        if (!entity) {\n          throw new NotFoundError('Entity not found');\n        }\n\n        const value = await deleteResolver(parent, { id: entity.id, params: transformedArgs });\n\n        return toEntityResponse(value, { args: transformedArgs, resourceUID: uid });\n      },\n    });\n  };\n\n  return {\n    buildSingleTypeMutations(contentType: Schema.SingleType) {\n      const updateMutationName = `Mutation.${getUpdateMutationTypeName(contentType)}`;\n      const deleteMutationName = `Mutation.${getDeleteMutationTypeName(contentType)}`;\n\n      const extension = getService('extension');\n\n      const registerAuthConfig = (action: string, auth: any) => {\n        return extension.use({ resolversConfig: { [action]: { auth } } });\n      };\n\n      const isActionEnabled = (action: string) => {\n        return extension.shadowCRUD(contentType.uid).isActionEnabled(action);\n      };\n\n      const isUpdateEnabled = isActionEnabled('update');\n      const isDeleteEnabled = isActionEnabled('delete');\n\n      if (isUpdateEnabled) {\n        registerAuthConfig(updateMutationName, { scope: [`${contentType.uid}.update`] });\n      }\n\n      if (isDeleteEnabled) {\n        registerAuthConfig(deleteMutationName, { scope: [`${contentType.uid}.delete`] });\n      }\n\n      return extendType({\n        type: 'Mutation',\n\n        definition(t) {\n          if (isUpdateEnabled) {\n            addUpdateMutation(t, contentType);\n          }\n\n          if (isDeleteEnabled) {\n            addDeleteMutation(t, contentType);\n          }\n        },\n      });\n    },\n  };\n};\n","import createCollectionTypeMutationsBuilder from './collection-type';\nimport createSingleTypeMutationsBuilder from './single-type';\nimport type { Context } from '../../types';\n\nexport default (context: Context) => ({\n  ...createCollectionTypeMutationsBuilder(context),\n  ...createSingleTypeMutationsBuilder(context),\n});\n","import { inputObjectType } from 'nexus';\nimport type * as Nexus from 'nexus';\nimport type { Attribute, Schema } from '@strapi/types';\nimport type { Context } from '../../types';\n\nexport default ({ strapi }: Context) => {\n  const rootLevelOperators = () => {\n    const { operators } = strapi.plugin('graphql').service('builders').filters;\n\n    return [operators.and, operators.or, operators.not];\n  };\n\n  const addScalarAttribute = (\n    builder: Nexus.blocks.InputDefinitionBlock<any>,\n    attributeName: string,\n    attribute: Attribute.Any\n  ) => {\n    const { naming, mappers } = strapi.plugin('graphql').service('utils');\n\n    const gqlType = mappers.strapiScalarToGraphQLScalar(attribute.type);\n\n    builder.field(attributeName, { type: naming.getScalarFilterInputTypeName(gqlType) });\n  };\n\n  const addRelationalAttribute = (\n    builder: Nexus.blocks.InputDefinitionBlock<any>,\n    attributeName: string,\n    attribute: Attribute.Relation\n  ) => {\n    const utils = strapi.plugin('graphql').service('utils');\n    const extension = strapi.plugin('graphql').service('extension');\n    const { getFiltersInputTypeName } = utils.naming;\n    const { isMorphRelation } = utils.attributes;\n\n    const model = 'target' in attribute && strapi.getModel(attribute.target);\n\n    // If there is no model corresponding to the attribute configuration\n    // or if the attribute is a polymorphic relation, then ignore it\n    if (!model || isMorphRelation(attribute)) return;\n\n    // If the target model is disabled, then ignore it too\n    if (extension.shadowCRUD(model.uid).isDisabled()) return;\n\n    builder.field(attributeName, { type: getFiltersInputTypeName(model) });\n  };\n\n  const addComponentAttribute = (\n    builder: Nexus.blocks.InputDefinitionBlock<any>,\n    attributeName: string,\n    attribute: Attribute.Component\n  ) => {\n    const utils = strapi.plugin('graphql').service('utils');\n    const extension = strapi.plugin('graphql').service('extension');\n    const { getFiltersInputTypeName } = utils.naming;\n\n    const component = strapi.getModel(attribute.component);\n\n    // If there is no component corresponding to the attribute configuration, then ignore it\n    if (!component) return;\n\n    // If the component is disabled, then ignore it too\n    if (extension.shadowCRUD(component.uid).isDisabled()) return;\n\n    builder.field(attributeName, { type: getFiltersInputTypeName(component) });\n  };\n\n  const buildContentTypeFilters = (contentType: Schema.ContentType) => {\n    const utils = strapi.plugin('graphql').service('utils');\n    const extension = strapi.plugin('graphql').service('extension');\n\n    const { getFiltersInputTypeName, getScalarFilterInputTypeName } = utils.naming;\n    const { isStrapiScalar, isRelation, isComponent } = utils.attributes;\n\n    const { attributes } = contentType;\n\n    const filtersTypeName = getFiltersInputTypeName(contentType);\n\n    return inputObjectType({\n      name: filtersTypeName,\n\n      definition(t) {\n        const validAttributes = Object.entries(attributes).filter(([attributeName]) =>\n          extension.shadowCRUD(contentType.uid).field(attributeName).hasFiltersEnabeld()\n        );\n\n        const isIDFilterEnabled = extension\n          .shadowCRUD(contentType.uid)\n          .field('id')\n          .hasFiltersEnabeld();\n        // Add an ID filter to the collection types\n        if (contentType.kind === 'collectionType' && isIDFilterEnabled) {\n          t.field('id', { type: getScalarFilterInputTypeName('ID') });\n        }\n\n        // Add every defined attribute\n        for (const [attributeName, attribute] of validAttributes) {\n          // Handle scalars\n          if (isStrapiScalar(attribute)) {\n            addScalarAttribute(t, attributeName, attribute);\n          }\n\n          // Handle relations\n          else if (isRelation(attribute)) {\n            addRelationalAttribute(t, attributeName, attribute as Attribute.Relation);\n          }\n\n          // Handle components\n          else if (isComponent(attribute)) {\n            addComponentAttribute(t, attributeName, attribute as Attribute.Component);\n          }\n        }\n\n        // Conditional clauses\n        for (const operator of rootLevelOperators()) {\n          operator.add(t, filtersTypeName);\n        }\n      },\n    });\n  };\n\n  return {\n    buildContentTypeFilters,\n  };\n};\n","import contentType from './content-type';\nimport type { Context } from '../../types';\n\nexport default (context: Context) => ({\n  ...contentType(context),\n});\n","import { inputObjectType, nonNull } from 'nexus';\nimport { contentTypes } from '@strapi/utils';\nimport type { Schema } from '@strapi/types';\nimport type { Context } from '../types';\n\nconst { isWritableAttribute } = contentTypes;\n\nexport default ({ strapi }: Context) => {\n  const { naming, mappers, attributes } = strapi.plugin('graphql').service('utils');\n  const extension = strapi.plugin('graphql').service('extension');\n\n  const { getComponentInputName, getContentTypeInputName, getEnumName, getDynamicZoneInputName } =\n    naming;\n\n  const {\n    isStrapiScalar,\n    isRelation,\n    isMorphRelation,\n    isMedia,\n    isEnumeration,\n    isComponent,\n    isDynamicZone,\n  } = attributes;\n\n  return {\n    buildInputType(contentType: Schema.Any) {\n      const { attributes, modelType } = contentType;\n\n      const name = (\n        modelType === 'component' ? getComponentInputName : getContentTypeInputName\n      ).call(null, contentType);\n\n      return inputObjectType({\n        name,\n\n        definition(t) {\n          const isFieldEnabled = (fieldName: string) => {\n            return extension.shadowCRUD(contentType.uid).field(fieldName).hasInputEnabled();\n          };\n\n          const validAttributes = Object.entries(attributes).filter(([attributeName]) => {\n            return isWritableAttribute(contentType, attributeName) && isFieldEnabled(attributeName);\n          });\n\n          // Add the ID for the component to enable inplace updates\n          if (modelType === 'component' && isFieldEnabled('id')) {\n            t.id('id');\n          }\n\n          validAttributes.forEach(([attributeName, attribute]: [string, any]) => {\n            // Enums\n            if (isEnumeration(attribute)) {\n              const enumTypeName = getEnumName(contentType, attributeName);\n\n              t.field(attributeName, { type: enumTypeName });\n            }\n\n            // Scalars\n            else if (isStrapiScalar(attribute)) {\n              const gqlScalar = mappers.strapiScalarToGraphQLScalar(attribute.type);\n\n              t.field(attributeName, { type: gqlScalar });\n            }\n\n            // Media\n            else if (isMedia(attribute)) {\n              const isMultiple = attribute.multiple === true;\n\n              if (extension.shadowCRUD('plugin::upload.file').isDisabled()) {\n                return;\n              }\n\n              if (isMultiple) {\n                t.list.id(attributeName);\n              } else {\n                t.id(attributeName);\n              }\n            }\n\n            // Regular Relations (ignore polymorphic relations)\n            else if (isRelation(attribute) && !isMorphRelation(attribute)) {\n              if (extension.shadowCRUD(attribute.target).isDisabled()) {\n                return;\n              }\n\n              const isToManyRelation = attribute.relation.endsWith('Many');\n\n              if (isToManyRelation) {\n                t.list.id(attributeName);\n              } else {\n                t.id(attributeName);\n              }\n            }\n\n            // Components\n            else if (isComponent(attribute)) {\n              const isRepeatable = attribute.repeatable === true;\n              const component = strapi.components[attribute.component];\n              const componentInputType = getComponentInputName(component);\n\n              if (isRepeatable) {\n                t.list.field(attributeName, { type: componentInputType });\n              } else {\n                t.field(attributeName, { type: componentInputType });\n              }\n            }\n\n            // Dynamic Zones\n            else if (isDynamicZone(attribute)) {\n              const dzInputName = getDynamicZoneInputName(contentType, attributeName);\n\n              t.list.field(attributeName, { type: nonNull(dzInputName) });\n            }\n          });\n        },\n      });\n    },\n  };\n};\n","import { unionType } from 'nexus';\nimport { prop } from 'lodash/fp';\n\nimport type { Context } from '../types';\n\nexport default ({ strapi, registry }: Context) => {\n  const { naming } = strapi.plugin('graphql').service('utils');\n  const { KINDS, GENERIC_MORPH_TYPENAME } = strapi.plugin('graphql').service('constants');\n\n  return {\n    buildGenericMorphDefinition() {\n      return unionType({\n        name: GENERIC_MORPH_TYPENAME,\n\n        resolveType(obj: any) {\n          const contentType = strapi.getModel(obj.__type);\n\n          if (!contentType) {\n            return null;\n          }\n\n          if (contentType.modelType === 'component') {\n            return naming.getComponentName(contentType);\n          }\n\n          return naming.getTypeName(contentType);\n        },\n\n        definition(t: any) {\n          const members = registry\n            // Resolve every content-type or component\n            .where(({ config }) => [KINDS.type, KINDS.component].includes(config.kind))\n            // Only keep their name (the type's id)\n            .map(prop('name'));\n\n          t.members(...members);\n        },\n      });\n    },\n  };\n};\n","import { get } from 'lodash/fp';\nimport { sanitize, validate, pipeAsync, errors } from '@strapi/utils';\nimport type { UID } from '@strapi/types';\n\nimport type { Context } from '../../types';\n\nconst { ApplicationError } = errors;\n\nexport default ({ strapi }: Context) => {\n  const { service: getGraphQLService } = strapi.plugin('graphql');\n\n  const { isMorphRelation, isMedia } = getGraphQLService('utils').attributes;\n  const { transformArgs } = getGraphQLService('builders').utils;\n  const { toEntityResponse, toEntityResponseCollection } = getGraphQLService('format').returnTypes;\n\n  return {\n    buildAssociationResolver({\n      contentTypeUID,\n      attributeName,\n    }: {\n      contentTypeUID: UID.ContentType;\n      attributeName: string;\n    }) {\n      const contentType = strapi.getModel(contentTypeUID);\n      const attribute: any = contentType.attributes[attributeName];\n\n      if (!attribute) {\n        throw new ApplicationError(\n          `Failed to build an association resolver for ${contentTypeUID}::${attributeName}`\n        );\n      }\n\n      const isMediaAttribute = isMedia(attribute);\n      const isMorphAttribute = isMorphRelation(attribute);\n\n      const targetUID = isMediaAttribute ? 'plugin::upload.file' : attribute.target;\n      const isToMany = isMediaAttribute ? attribute.multiple : attribute.relation.endsWith('Many');\n\n      const targetContentType = strapi.getModel(targetUID);\n\n      return async (parent: any, args: any = {}, context: any = {}) => {\n        const { auth } = context.state;\n\n        const transformedArgs = transformArgs(args, {\n          contentType: targetContentType,\n          usePagination: true,\n        });\n\n        await validate.contentAPI.query(transformedArgs, targetContentType, {\n          auth,\n        });\n        const sanitizedQuery = await sanitize.contentAPI.query(transformedArgs, targetContentType, {\n          auth,\n        });\n\n        const data = await strapi.entityService!.load(\n          contentTypeUID,\n          parent,\n          attributeName,\n          sanitizedQuery\n        );\n\n        const info = {\n          args: sanitizedQuery,\n          resourceUID: targetUID,\n        };\n\n        // If this a polymorphic association, it sanitizes & returns the raw data\n        // Note: The value needs to be wrapped in a fake object that represents its parent\n        // so that the sanitize util can work properly.\n        if (isMorphAttribute) {\n          // Helpers used for the data cleanup\n          const wrapData = (dataToWrap: any) => ({ [attributeName]: dataToWrap });\n          const sanitizeData = (dataToSanitize: any) => {\n            return sanitize.contentAPI.output(dataToSanitize, contentType, { auth });\n          };\n          const unwrapData = get(attributeName);\n\n          // Sanitizer definition\n          const sanitizeMorphAttribute = pipeAsync(wrapData, sanitizeData, unwrapData);\n\n          return sanitizeMorphAttribute(data);\n        }\n\n        // If this is a to-many relation, it returns an object that\n        // matches what the entity-response-collection's resolvers expect\n        if (isToMany) {\n          return toEntityResponseCollection(data, info);\n        }\n\n        // Else, it returns an object that matches\n        // what the entity-response's resolvers expect\n        return toEntityResponse(data, info);\n      };\n    },\n  };\n};\n","import { omit } from 'lodash/fp';\nimport { sanitize, validate } from '@strapi/utils';\nimport type { Schema } from '@strapi/types';\nimport type { Context } from '../../types';\n\nexport default ({ strapi }: Context) => ({\n  buildQueriesResolvers({ contentType }: { contentType: Schema.ContentType }) {\n    const { uid } = contentType;\n\n    return {\n      async find(parent: any, args: any, ctx: any) {\n        await validate.contentAPI.query(args, contentType, {\n          auth: ctx?.state?.auth,\n        });\n        const sanitizedQuery = await sanitize.contentAPI.query(args, contentType, {\n          auth: ctx?.state?.auth,\n        });\n\n        return strapi.entityService!.findMany(uid, sanitizedQuery);\n      },\n\n      async findOne(parent: any, args: any, ctx: any) {\n        await validate.contentAPI.query(args, contentType, {\n          auth: ctx?.state?.auth,\n        });\n        const sanitizedQuery = await sanitize.contentAPI.query(args, contentType, {\n          auth: ctx?.state?.auth,\n        });\n\n        return strapi.entityService!.findOne(uid, args.id, omit('id', sanitizedQuery));\n      },\n    };\n  },\n});\n","import { pick } from 'lodash/fp';\nimport { sanitize, validate } from '@strapi/utils';\nimport type { Schema } from '@strapi/types';\nimport type { Context } from '../../types';\n\nconst pickCreateArgs = pick(['params', 'data', 'files']);\n\nexport default ({ strapi }: Context) => ({\n  buildMutationsResolvers({ contentType }: { contentType: Schema.ContentType }) {\n    const { uid } = contentType;\n\n    return {\n      async create(parent: any, args: any) {\n        // todo[v4]: Might be interesting to generate dynamic yup schema to validate payloads with more complex checks (on top of graphql validation)\n        const params = pickCreateArgs(args);\n\n        // todo[v4]: Sanitize args to only keep params / data / files (or do it in the base resolver)\n        return strapi.entityService!.create(uid, params);\n      },\n\n      async update(parent: any, args: any) {\n        const { id, data } = args;\n        return strapi.entityService!.update(uid, id, { data });\n      },\n\n      async delete(parent: any, args: any, ctx: any) {\n        const { id, ...rest } = args;\n        await validate.contentAPI.query(rest, contentType, {\n          auth: ctx?.state?.auth,\n        });\n        const sanitizedQuery = await sanitize.contentAPI.query(rest, contentType, {\n          auth: ctx?.state?.auth,\n        });\n        return strapi.entityService!.delete(uid, id, sanitizedQuery);\n      },\n    };\n  },\n});\n","import { sanitize, validate } from '@strapi/utils';\nimport type { Attribute, UID } from '@strapi/types';\n\nimport type { Context } from '../../types';\n\nexport default ({ strapi }: Context) => ({\n  buildComponentResolver({\n    contentTypeUID,\n    attributeName,\n  }: {\n    contentTypeUID: UID.ContentType;\n    attributeName: string;\n  }) {\n    const { transformArgs } = strapi.plugin('graphql').service('builders').utils;\n\n    return async (parent: any, args: any, ctx: any) => {\n      const contentType = strapi.getModel(contentTypeUID);\n\n      const { component: componentName } = contentType.attributes[\n        attributeName\n      ] as Attribute.Component;\n      const component = strapi.getModel(componentName);\n\n      const transformedArgs = transformArgs(args, { contentType: component, usePagination: true });\n      await validate.contentAPI.query(transformedArgs, component, {\n        auth: ctx?.state?.auth,\n      });\n      const sanitizedQuery = await sanitize.contentAPI.query(transformedArgs, component, {\n        auth: ctx?.state?.auth,\n      });\n      return strapi.entityService!.load(contentTypeUID, parent, attributeName, sanitizedQuery);\n    };\n  },\n});\n","import type { UID } from '@strapi/types';\n\nimport type { Context } from '../../types';\n\nexport default ({ strapi }: Context) => ({\n  buildDynamicZoneResolver({\n    contentTypeUID,\n    attributeName,\n  }: {\n    contentTypeUID: UID.ContentType;\n    attributeName: string;\n  }) {\n    return async (parent: any) => {\n      return strapi.entityService!.load(contentTypeUID, parent, attributeName);\n    };\n  },\n});\n","import associationResolvers from './association';\nimport queriesResolvers from './query';\nimport mutationsResolvers from './mutation';\nimport componentResolvers from './component';\nimport dynamicZoneResolvers from './dynamic-zone';\n\nimport type { Context } from '../../types';\n\nexport default (context: Context) => ({\n  // Generics\n  ...associationResolvers(context),\n\n  // Builders\n  ...mutationsResolvers(context),\n  ...queriesResolvers(context),\n  ...componentResolvers(context),\n  ...dynamicZoneResolvers(context),\n});\n","import { list } from 'nexus';\nimport type * as Nexus from 'nexus';\n\nconst AND_FIELD_NAME = 'and';\n\nexport default () => ({\n  fieldName: AND_FIELD_NAME,\n\n  strapiOperator: '$and',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(AND_FIELD_NAME, { type: list(type) });\n  },\n});\n","import { list } from 'nexus';\nimport type * as Nexus from 'nexus';\n\nconst OR_FIELD_NAME = 'or';\n\nexport default () => ({\n  fieldName: OR_FIELD_NAME,\n\n  strapiOperator: '$or',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(OR_FIELD_NAME, { type: list(type) });\n  },\n});\n","import type * as Nexus from 'nexus';\nimport type { Strapi } from '@strapi/types';\n\nconst NOT_FIELD_NAME = 'not';\n\nexport default ({ strapi }: { strapi: Strapi }) => ({\n  fieldName: NOT_FIELD_NAME,\n\n  strapiOperator: '$not',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    const { naming, attributes } = strapi.plugin('graphql').service('utils');\n\n    if (attributes.isGraphQLScalar({ type })) {\n      t.field(NOT_FIELD_NAME, { type: naming.getScalarFilterInputTypeName(type) });\n    } else {\n      t.field(NOT_FIELD_NAME, { type });\n    }\n  },\n});\n","import { errors } from '@strapi/utils';\nimport type * as Nexus from 'nexus';\nimport type { Strapi } from '@strapi/types';\n\nconst { ValidationError } = errors;\n\nconst EQ_FIELD_NAME = 'eq';\n\nexport default ({ strapi }: { strapi: Strapi }) => ({\n  fieldName: EQ_FIELD_NAME,\n\n  strapiOperator: '$eq',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    const { GRAPHQL_SCALARS } = strapi.plugin('graphql').service('constants');\n\n    if (!GRAPHQL_SCALARS.includes(type)) {\n      throw new ValidationError(\n        `Can't use \"${EQ_FIELD_NAME}\" operator. \"${type}\" is not a valid scalar`\n      );\n    }\n\n    t.field(EQ_FIELD_NAME, { type });\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst EQI_FIELD_NAME = 'eqi';\n\nexport default () => ({\n  fieldName: EQI_FIELD_NAME,\n\n  strapiOperator: '$eqi',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(EQI_FIELD_NAME, { type });\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst NE_FIELD_NAME = 'ne';\n\nexport default () => ({\n  fieldName: NE_FIELD_NAME,\n\n  strapiOperator: '$ne',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(NE_FIELD_NAME, { type });\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst NEI_FIELD_NAME = 'nei';\n\nexport default () => ({\n  fieldName: NEI_FIELD_NAME,\n\n  strapiOperator: '$nei',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(NEI_FIELD_NAME, { type });\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst STARTS_WITH_FIELD_NAME = 'startsWith';\n\nexport default () => ({\n  fieldName: STARTS_WITH_FIELD_NAME,\n\n  strapiOperator: '$startsWith',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(STARTS_WITH_FIELD_NAME, { type });\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst ENDS_WITH_FIELD_NAME = 'endsWith';\n\nexport default () => ({\n  fieldName: ENDS_WITH_FIELD_NAME,\n\n  strapiOperator: '$endsWith',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(ENDS_WITH_FIELD_NAME, { type });\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst CONTAINS_FIELD_NAME = 'contains';\n\nexport default () => ({\n  fieldName: CONTAINS_FIELD_NAME,\n\n  strapiOperator: '$contains',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(CONTAINS_FIELD_NAME, { type });\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst NOT_CONTAINS_FIELD_NAME = 'notContains';\n\nexport default () => ({\n  fieldName: NOT_CONTAINS_FIELD_NAME,\n\n  strapiOperator: '$notContains',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(NOT_CONTAINS_FIELD_NAME, { type });\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst CONTAINSI_FIELD_NAME = 'containsi';\n\nexport default () => ({\n  fieldName: CONTAINSI_FIELD_NAME,\n\n  strapiOperator: '$containsi',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(CONTAINSI_FIELD_NAME, { type });\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst NOT_CONTAINSI_FIELD_NAME = 'notContainsi';\n\nexport default () => ({\n  fieldName: NOT_CONTAINSI_FIELD_NAME,\n\n  strapiOperator: '$notContainsi',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(NOT_CONTAINSI_FIELD_NAME, { type });\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst GT_FIELD_NAME = 'gt';\n\nexport default () => ({\n  fieldName: GT_FIELD_NAME,\n\n  strapiOperator: '$gt',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(GT_FIELD_NAME, { type });\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst GTE_FIELD_NAME = 'gte';\n\nexport default () => ({\n  fieldName: GTE_FIELD_NAME,\n\n  strapiOperator: '$gte',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(GTE_FIELD_NAME, { type });\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst LT_FIELD_NAME = 'lt';\n\nexport default () => ({\n  fieldName: LT_FIELD_NAME,\n\n  strapiOperator: '$lt',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(LT_FIELD_NAME, { type });\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst LTE_FIELD_NAME = 'lte';\n\nexport default () => ({\n  fieldName: LTE_FIELD_NAME,\n\n  strapiOperator: '$lte',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(LTE_FIELD_NAME, { type });\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst NULL_FIELD_NAME = 'null';\n\nexport default () => ({\n  fieldName: NULL_FIELD_NAME,\n\n  strapiOperator: '$null',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>) {\n    t.boolean(NULL_FIELD_NAME);\n  },\n});\n","import type * as Nexus from 'nexus';\n\nconst NOT_NULL_FIELD_NAME = 'notNull';\n\nexport default () => ({\n  fieldName: NOT_NULL_FIELD_NAME,\n\n  strapiOperator: '$notNull',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>) {\n    t.boolean(NOT_NULL_FIELD_NAME);\n  },\n});\n","import { list } from 'nexus';\nimport type * as Nexus from 'nexus';\n\nconst IN_FIELD_NAME = 'in';\n\nexport default () => ({\n  fieldName: IN_FIELD_NAME,\n\n  strapiOperator: '$in',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(IN_FIELD_NAME, { type: list(type) });\n  },\n});\n","import { list } from 'nexus';\nimport type * as Nexus from 'nexus';\n\nconst NOT_IN_FIELD_NAME = 'notIn';\n\nexport default () => ({\n  fieldName: NOT_IN_FIELD_NAME,\n\n  strapiOperator: '$notIn',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(NOT_IN_FIELD_NAME, { type: list(type) });\n  },\n});\n","import { list } from 'nexus';\nimport type * as Nexus from 'nexus';\n\nconst BETWEEN_FIELD_NAME = 'between';\n\nexport default () => ({\n  fieldName: BETWEEN_FIELD_NAME,\n\n  strapiOperator: '$between',\n\n  add(t: Nexus.blocks.ObjectDefinitionBlock<string>, type: string) {\n    t.field(BETWEEN_FIELD_NAME, { type: list(type) });\n  },\n});\n","import type { Strapi } from '@strapi/types';\n\nimport { mapValues } from 'lodash/fp';\nimport andOperator from './and';\nimport orOperator from './or';\nimport notOperator from './not';\nimport eqOperator from './eq';\nimport eqiOperator from './eqi';\nimport neOperator from './ne';\nimport neiOperator from './nei';\nimport startsWithOperator from './starts-with';\nimport endsWithOperator from './ends-with';\nimport containsOperator from './contains';\nimport notContainsOperator from './not-contains';\nimport containsiOperator from './containsi';\nimport notContainsiOperator from './not-containsi';\nimport gtOperator from './gt';\nimport gteOperator from './gte';\nimport ltOperator from './lt';\nimport lteOperator from './lte';\nimport nullOperator from './null';\nimport notNullOperator from './not-null';\nimport inOperator from './in';\nimport notInOperator from './not-in';\nimport betweenOperator from './between';\n\nconst operators = {\n  and: andOperator,\n  or: orOperator,\n  not: notOperator,\n  eq: eqOperator,\n  eqi: eqiOperator,\n  ne: neOperator,\n  nei: neiOperator,\n  startsWith: startsWithOperator,\n  endsWith: endsWithOperator,\n  contains: containsOperator,\n  notContains: notContainsOperator,\n  containsi: containsiOperator,\n  notContainsi: notContainsiOperator,\n  gt: gtOperator,\n  gte: gteOperator,\n  lt: ltOperator,\n  lte: lteOperator,\n  null: nullOperator,\n  notNull: notNullOperator,\n  in: inOperator,\n  notIn: notInOperator,\n  between: betweenOperator,\n};\n\n// Instantiate every operator with the Strapi instance\nexport default ({ strapi }: { strapi: Strapi }) =>\n  mapValues((opCtor) => opCtor({ strapi }), operators);\n","import { entries, mapValues, omit } from 'lodash/fp';\nimport { pagination, contentTypes } from '@strapi/utils';\nimport type { Strapi, Schema } from '@strapi/types';\n\nconst { withDefaultPagination } = pagination;\nconst { hasDraftAndPublish } = contentTypes;\n\nexport default ({ strapi }: { strapi: Strapi }) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  return {\n    /**\n     * Get every args for a given content type\n     * @param {object} contentType\n     * @param {object} options\n     * @param {boolean} options.multiple\n     * @return {object}\n     */\n    getContentTypeArgs(contentType: Schema.Any, { multiple = true } = {}) {\n      const { naming } = getService('utils');\n      const { args } = getService('internals');\n\n      const { modelType } = contentType;\n\n      // Components\n      if (modelType === 'component') {\n        if (!multiple) return {};\n\n        return {\n          filters: naming.getFiltersInputTypeName(contentType),\n          pagination: args.PaginationArg,\n          sort: args.SortArg,\n        };\n      }\n\n      const { kind } = contentType;\n\n      // Collection Types\n      if (kind === 'collectionType') {\n        if (!multiple) {\n          return { id: 'ID' };\n        }\n\n        const params = {\n          filters: naming.getFiltersInputTypeName(contentType),\n          pagination: args.PaginationArg,\n          sort: args.SortArg,\n        };\n\n        if (hasDraftAndPublish(contentType)) {\n          Object.assign(params, { publicationState: args.PublicationStateArg });\n        }\n\n        return params;\n      }\n\n      // Single Types\n      if (kind === 'singleType') {\n        const params = {};\n\n        if (hasDraftAndPublish(contentType)) {\n          Object.assign(params, { publicationState: args.PublicationStateArg });\n        }\n\n        return params;\n      }\n    },\n\n    /**\n     * Filter an object entries and keep only those whose value is a unique scalar attribute\n     */\n    getUniqueScalarAttributes(attributes: Schema.Attributes) {\n      const { isStrapiScalar } = getService('utils').attributes;\n\n      const uniqueAttributes = entries(attributes).filter(\n        ([, attribute]) => isStrapiScalar(attribute) && 'unique' in attribute && attribute.unique\n      );\n\n      return Object.fromEntries(uniqueAttributes);\n    },\n\n    /**\n     * Map each value from an attribute to a FiltersInput type name\n     * @param {object} attributes - The attributes object to transform\n     * @return {Object<string, string>}\n     */\n    scalarAttributesToFiltersMap(attributes: Schema.Attributes) {\n      return mapValues((attribute) => {\n        const { mappers, naming } = getService('utils');\n\n        const gqlScalar = mappers.strapiScalarToGraphQLScalar(attribute.type);\n\n        return naming.getScalarFilterInputTypeName(gqlScalar);\n      }, attributes);\n    },\n\n    /**\n     * Apply basic transform to GQL args\n     */\n    transformArgs(\n      args: any,\n      {\n        contentType,\n        usePagination = false,\n      }: { contentType: Schema.ContentType; usePagination?: boolean }\n    ) {\n      const { mappers } = getService('utils');\n      const { config } = strapi.plugin('graphql');\n      const { pagination = {}, filters = {} } = args;\n\n      // Init\n      const newArgs = omit(['pagination', 'filters'], args);\n\n      // Pagination\n      if (usePagination) {\n        const defaultLimit: number = config('defaultLimit');\n        const maxLimit: number = config('maxLimit');\n\n        Object.assign(\n          newArgs,\n          withDefaultPagination(pagination, {\n            maxLimit,\n            defaults: {\n              offset: { limit: defaultLimit },\n              page: { pageSize: defaultLimit },\n            },\n          })\n        );\n      }\n\n      // Filters\n      if (args.filters) {\n        Object.assign(newArgs, {\n          filters: mappers.graphQLFiltersToStrapiQuery(filters, contentType),\n        });\n      }\n\n      return newArgs;\n    },\n  };\n};\n","import { merge, map, pipe, reduce } from 'lodash/fp';\nimport type { Strapi } from '@strapi/types';\n\n// Builders Factories\n\nimport enums from './enums';\nimport dynamicZone from './dynamic-zones';\nimport entity from './entity';\nimport entityMeta from './entity-meta';\nimport typeBuilder from './type';\nimport response from './response';\nimport responseCollection from './response-collection';\nimport relationResponseCollection from './relation-response-collection';\nimport queries from './queries';\nimport mutations from './mutations';\nimport filters from './filters';\nimport inputs from './input';\nimport genericMorph from './generic-morph';\nimport resolvers from './resolvers';\n\n// Misc\n\nimport operators from './filters/operators';\nimport utils from './utils';\nimport type { TypeRegistry } from '../type-registry';\n\nconst buildersFactories = [\n  enums,\n  dynamicZone,\n  entity,\n  entityMeta,\n  typeBuilder,\n  response,\n  responseCollection,\n  relationResponseCollection,\n  queries,\n  mutations,\n  filters,\n  inputs,\n  genericMorph,\n  resolvers,\n];\n\nexport default ({ strapi }: { strapi: Strapi }) => {\n  const buildersMap = new Map();\n\n  return {\n    /**\n     * Instantiate every builder with a strapi instance & a type registry\n     */\n    new(name: string, registry: TypeRegistry) {\n      const context = { strapi, registry };\n\n      const builders = pipe(\n        // Create a new instance of every builders\n        map((factory: any) => factory(context)),\n        // Merge every builder into the same object\n        reduce(merge, {})\n      ).call(null, buildersFactories);\n\n      buildersMap.set(name, builders);\n\n      return builders;\n    },\n\n    /**\n     * Delete a set of builders instances from\n     * the builders map for a given name\n     */\n    delete(name: string) {\n      buildersMap.delete(name);\n    },\n\n    /**\n     * Retrieve a set of builders instances from\n     * the builders map for a given name\n     */\n    get(name: string) {\n      return buildersMap.get(name);\n    },\n\n    filters: {\n      operators: operators({ strapi }),\n    },\n\n    utils: utils({ strapi }),\n  };\n};\n","export type ContentTypeConfig = {\n  enabled: boolean;\n\n  mutations: boolean;\n  queries: boolean;\n\n  disabledActions: string[];\n  fields: Map<string, FieldConfig>;\n};\n\nexport type FieldConfig = {\n  enabled: boolean;\n\n  input: boolean;\n  output: boolean;\n\n  filters: boolean;\n};\n\nconst getDefaultContentTypeConfig = (): ContentTypeConfig => ({\n  enabled: true,\n\n  mutations: true,\n  queries: true,\n\n  disabledActions: [],\n  fields: new Map(),\n});\n\nconst getDefaultFieldConfig = (): FieldConfig => ({\n  enabled: true,\n\n  input: true,\n  output: true,\n\n  filters: true,\n});\n\nconst ALL_ACTIONS = '*';\n\nexport default () => {\n  const configs = new Map<string, ContentTypeConfig>();\n\n  return (uid: string) => {\n    if (!configs.has(uid)) {\n      configs.set(uid, getDefaultContentTypeConfig());\n    }\n\n    return {\n      isEnabled() {\n        return configs.get(uid)!.enabled;\n      },\n\n      isDisabled() {\n        return !this.isEnabled();\n      },\n\n      areQueriesEnabled() {\n        return configs.get(uid)!.queries;\n      },\n\n      areQueriesDisabled() {\n        return !this.areQueriesEnabled();\n      },\n\n      areMutationsEnabled() {\n        return configs.get(uid)!.mutations;\n      },\n\n      areMutationsDisabled() {\n        return !this.areMutationsEnabled();\n      },\n\n      isActionEnabled(action: string) {\n        const matchingActions = [action, ALL_ACTIONS];\n\n        return configs\n          .get(uid)!\n          .disabledActions.every((action) => !matchingActions.includes(action));\n      },\n\n      isActionDisabled(action: string) {\n        return !this.isActionEnabled(action);\n      },\n\n      disable() {\n        configs.get(uid)!.enabled = false;\n\n        return this;\n      },\n\n      disableQueries() {\n        configs.get(uid)!.queries = false;\n\n        return this;\n      },\n\n      disableMutations() {\n        configs.get(uid)!.mutations = false;\n\n        return this;\n      },\n\n      disableAction(action: string) {\n        const config = configs.get(uid)!;\n\n        if (!config.disabledActions.includes(action)) {\n          config.disabledActions.push(action);\n        }\n\n        return this;\n      },\n\n      disableActions(actions = []) {\n        actions.forEach((action) => this.disableAction(action));\n\n        return this;\n      },\n\n      field(fieldName: string) {\n        const { fields } = configs.get(uid)!;\n\n        if (!fields.has(fieldName)) {\n          fields.set(fieldName, getDefaultFieldConfig());\n        }\n\n        return {\n          isEnabled() {\n            return fields.get(fieldName)!.enabled;\n          },\n\n          hasInputEnabled() {\n            return fields.get(fieldName)!.input;\n          },\n\n          hasOutputEnabled() {\n            return fields.get(fieldName)!.output;\n          },\n\n          hasFiltersEnabeld() {\n            return fields.get(fieldName)!.filters;\n          },\n\n          disable() {\n            fields.set(fieldName, {\n              enabled: false,\n\n              output: false,\n              input: false,\n\n              filters: false,\n            });\n\n            return this;\n          },\n\n          disableOutput() {\n            fields.get(fieldName)!.output = false;\n\n            return this;\n          },\n\n          disableInput() {\n            fields.get(fieldName)!.input = false;\n\n            return this;\n          },\n\n          disableFilters() {\n            fields.get(fieldName)!.filters = false;\n\n            return this;\n          },\n        };\n      },\n    };\n  };\n};\n","import * as nexus from 'nexus';\nimport { merge } from 'lodash/fp';\nimport type { Strapi } from '@strapi/types';\nimport type * as Nexus from 'nexus';\n\nimport createShadowCRUDManager from './shadow-crud-manager';\n\nexport type Configuration = {\n  types?: NexusGen[];\n  typeDefs?: string;\n  resolvers?: object;\n  resolversConfig?: object;\n  plugins?: Nexus.PluginConfig[];\n};\n\nexport type ConfigurationFactory = (options: {\n  strapi: Strapi;\n  nexus: typeof nexus;\n  typeRegistry: object;\n}) => Configuration;\n\nexport type Extension = {\n  types: NexusGen[];\n  typeDefs: string[];\n  resolvers: object;\n  resolversConfig: object;\n  plugins: Nexus.PluginConfig[];\n};\n\nconst getDefaultState = (): Extension => ({\n  types: [],\n  typeDefs: [],\n  resolvers: {},\n  resolversConfig: {},\n  plugins: [],\n});\n\nconst createExtension = ({ strapi }: { strapi: Strapi }) => {\n  const configs: Array<Configuration | ConfigurationFactory> = [];\n\n  return {\n    shadowCRUD: createShadowCRUDManager(),\n\n    /**\n     * Register a new extension configuration\n     */\n    use(configuration: Configuration | ConfigurationFactory) {\n      configs.push(configuration);\n\n      return this;\n    },\n\n    /**\n     * Convert the registered configuration into a single extension object & return it\n     */\n    generate({ typeRegistry }: { typeRegistry: object }) {\n      const resolveConfig = (config: Configuration | ConfigurationFactory): Configuration => {\n        return typeof config === 'function' ? config({ strapi, nexus, typeRegistry }) : config;\n      };\n\n      // Evaluate & merge every registered configuration object, then return the result\n      return configs.reduce((acc, configuration) => {\n        const { types, typeDefs, resolvers, resolversConfig, plugins } =\n          resolveConfig(configuration);\n\n        // Register type definitions\n        if (typeof typeDefs === 'string') {\n          acc.typeDefs.push(typeDefs);\n        }\n\n        // Register nexus types\n        if (Array.isArray(types)) {\n          acc.types.push(...types);\n        }\n\n        // Register nexus plugins\n        if (Array.isArray(plugins)) {\n          acc.plugins.push(...plugins);\n        }\n\n        // Register resolvers\n        if (typeof resolvers === 'object') {\n          acc.resolvers = merge(acc.resolvers, resolvers);\n        }\n\n        // Register resolvers configuration\n        if (typeof resolversConfig === 'object') {\n          // TODO: smarter merge for auth, middlewares & policies\n          acc.resolversConfig = merge(resolversConfig, acc.resolversConfig);\n        }\n\n        return acc;\n      }, getDefaultState());\n    },\n  };\n};\n\nexport default createExtension;\n","export type InfoType = {\n  args?: unknown;\n  resourceUID?: string;\n};\n\nexport default () => ({\n  toEntityResponse(value: unknown, info: InfoType = {}) {\n    const { args = {}, resourceUID } = info;\n\n    return { value, info: { args, resourceUID } };\n  },\n\n  toEntityResponseCollection(nodes: unknown[], info: InfoType = {}) {\n    const { args = {}, resourceUID } = info;\n\n    return { nodes, info: { args, resourceUID } };\n  },\n});\n","import returnTypes from './return-types';\n\nexport default () => ({\n  returnTypes: returnTypes(),\n});\n","import contentAPI from './content-api';\nimport typeRegistry from './type-registry';\nimport utils from './utils';\nimport constants from './constants';\nimport internals from './internals';\nimport builders from './builders';\nimport extension from './extension';\nimport format from './format';\n\nexport const services = {\n  builders,\n  'content-api': contentAPI,\n  constants,\n  extension,\n  format,\n  internals,\n  'type-registry': typeRegistry,\n  utils,\n};\n","import { config } from './config';\nimport { bootstrap } from './bootstrap';\nimport { services } from './services';\n\nexport default {\n  config,\n  bootstrap,\n  services,\n};\n"],"names":["ForbiddenError","ApplicationError","ValidationError","error","ApolloForbiddenError","ApolloUserInputError","strapi","config","policyUtils","args","index","contentType","builders","naming","KINDS","types","attributes","scalars","registerDynamicZonesDefinition","registerEnumsDefinition","registerInputsDefinition","registerFiltersDefinition","GENERIC_MORPH_TYPENAME","registry","extensionService","contentTypes","typeRegistry","STRAPI_SCALARS","SCALARS_ASSOCIATIONS","operators","filters","GRAPHQL_SCALAR_OPERATORS","entity","entityToResponseEntity","scalarType","PUBLICATION_STATE_TYPE_NAME","publicationState","PAGINATION_TYPE_NAME","RESPONSE_COLLECTION_META_TYPE_NAME","mappers","helpers","ERROR_CODES","ERROR_TYPE_NAME","isEmpty","component","extension","utils","queriesResolvers","GRAPHQL_SCALARS","pagination","merge","action","resolvers"],"mappings":"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"}