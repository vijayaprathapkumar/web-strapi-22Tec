"use strict";
const utils = require("@strapi/utils");
const lodash = require("lodash");
const _ = require("lodash/fp");
const EE = require("@strapi/strapi/dist/utils/ee");
const yup = require("yup");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const ___default = /* @__PURE__ */ _interopDefault(_);
const EE__default = /* @__PURE__ */ _interopDefault(EE);
const yup__namespace = /* @__PURE__ */ _interopNamespace(yup);
const RELEASE_MODEL_UID = "plugin::content-releases.release";
const RELEASE_ACTION_MODEL_UID = "plugin::content-releases.release-action";
const ACTIONS = [
  {
    section: "plugins",
    displayName: "Read",
    uid: "read",
    pluginName: "content-releases"
  },
  {
    section: "plugins",
    displayName: "Create",
    uid: "create",
    pluginName: "content-releases"
  },
  {
    section: "plugins",
    displayName: "Edit",
    uid: "update",
    pluginName: "content-releases"
  },
  {
    section: "plugins",
    displayName: "Delete",
    uid: "delete",
    pluginName: "content-releases"
  },
  {
    section: "plugins",
    displayName: "Publish",
    uid: "publish",
    pluginName: "content-releases"
  },
  {
    section: "plugins",
    displayName: "Remove an entry from a release",
    uid: "delete-action",
    pluginName: "content-releases"
  },
  {
    section: "plugins",
    displayName: "Add an entry to a release",
    uid: "create-action",
    pluginName: "content-releases"
  }
];
async function deleteActionsOnDisableDraftAndPublish({
  oldContentTypes,
  contentTypes: contentTypes2
}) {
  if (!oldContentTypes) {
    return;
  }
  for (const uid in contentTypes2) {
    if (!oldContentTypes[uid]) {
      continue;
    }
    const oldContentType = oldContentTypes[uid];
    const contentType = contentTypes2[uid];
    if (utils.contentTypes.hasDraftAndPublish(oldContentType) && !utils.contentTypes.hasDraftAndPublish(contentType)) {
      await strapi.db?.queryBuilder(RELEASE_ACTION_MODEL_UID).delete().where({ contentType: uid }).execute();
    }
  }
}
async function deleteActionsOnDeleteContentType({ oldContentTypes, contentTypes: contentTypes2 }) {
  const deletedContentTypes = lodash.difference(lodash.keys(oldContentTypes), lodash.keys(contentTypes2)) ?? [];
  if (deletedContentTypes.length) {
    await utils.mapAsync(deletedContentTypes, async (deletedContentTypeUID) => {
      return strapi.db?.queryBuilder(RELEASE_ACTION_MODEL_UID).delete().where({ contentType: deletedContentTypeUID }).execute();
    });
  }
}
const { features: features$2 } = require("@strapi/strapi/dist/utils/ee");
const register = async ({ strapi: strapi2 }) => {
  if (features$2.isEnabled("cms-content-releases")) {
    await strapi2.admin.services.permission.actionProvider.registerMany(ACTIONS);
    strapi2.hook("strapi::content-types.beforeSync").register(deleteActionsOnDisableDraftAndPublish);
    strapi2.hook("strapi::content-types.afterSync").register(deleteActionsOnDeleteContentType);
  }
};
const { features: features$1 } = require("@strapi/strapi/dist/utils/ee");
const bootstrap = async ({ strapi: strapi2 }) => {
  if (features$1.isEnabled("cms-content-releases")) {
    strapi2.db.lifecycles.subscribe({
      afterDelete(event) {
        const { model, result } = event;
        if (model.kind === "collectionType" && model.options?.draftAndPublish) {
          const { id } = result;
          strapi2.db.query(RELEASE_ACTION_MODEL_UID).deleteMany({
            where: {
              target_type: model.uid,
              target_id: id
            }
          });
        }
      },
      /**
       * deleteMany hook doesn't return the deleted entries ids
       * so we need to fetch them before deleting the entries to save the ids on our state
       */
      async beforeDeleteMany(event) {
        const { model, params } = event;
        if (model.kind === "collectionType" && model.options?.draftAndPublish) {
          const { where } = params;
          const entriesToDelete = await strapi2.db.query(model.uid).findMany({ select: ["id"], where });
          event.state.entriesToDelete = entriesToDelete;
        }
      },
      /**
       * We delete the release actions related to deleted entries
       * We make this only after deleteMany is succesfully executed to avoid errors
       */
      async afterDeleteMany(event) {
        const { model, state } = event;
        const entriesToDelete = state.entriesToDelete;
        if (entriesToDelete) {
          await strapi2.db.query(RELEASE_ACTION_MODEL_UID).deleteMany({
            where: {
              target_type: model.uid,
              target_id: {
                $in: entriesToDelete.map((entry) => entry.id)
              }
            }
          });
        }
      }
    });
  }
};
const schema$1 = {
  collectionName: "strapi_releases",
  info: {
    singularName: "release",
    pluralName: "releases",
    displayName: "Release"
  },
  options: {
    draftAndPublish: false
  },
  pluginOptions: {
    "content-manager": {
      visible: false
    },
    "content-type-builder": {
      visible: false
    }
  },
  attributes: {
    name: {
      type: "string",
      required: true
    },
    releasedAt: {
      type: "datetime"
    },
    actions: {
      type: "relation",
      relation: "oneToMany",
      target: RELEASE_ACTION_MODEL_UID,
      mappedBy: "release"
    }
  }
};
const release$1 = {
  schema: schema$1
};
const schema = {
  collectionName: "strapi_release_actions",
  info: {
    singularName: "release-action",
    pluralName: "release-actions",
    displayName: "Release Action"
  },
  options: {
    draftAndPublish: false
  },
  pluginOptions: {
    "content-manager": {
      visible: false
    },
    "content-type-builder": {
      visible: false
    }
  },
  attributes: {
    type: {
      type: "enumeration",
      enum: ["publish", "unpublish"],
      required: true
    },
    entry: {
      type: "relation",
      relation: "morphToOne",
      configurable: false
    },
    contentType: {
      type: "string",
      required: true
    },
    locale: {
      type: "string"
    },
    release: {
      type: "relation",
      relation: "manyToOne",
      target: RELEASE_MODEL_UID,
      inversedBy: "actions"
    }
  }
};
const releaseAction$1 = {
  schema
};
const contentTypes = {
  release: release$1,
  "release-action": releaseAction$1
};
const getService = (name, { strapi: strapi2 } = { strapi: global.strapi }) => {
  return strapi2.plugin("content-releases").service(name);
};
const getGroupName = (queryValue) => {
  switch (queryValue) {
    case "contentType":
      return "contentType.displayName";
    case "action":
      return "type";
    case "locale":
      return ___default.default.getOr("No locale", "locale.name");
    default:
      return "contentType.displayName";
  }
};
const createReleaseService = ({ strapi: strapi2 }) => ({
  async create(releaseData, { user }) {
    const releaseWithCreatorFields = await utils.setCreatorFields({ user })(releaseData);
    const { validatePendingReleasesLimit, validateUniqueNameForPendingRelease } = getService(
      "release-validation",
      { strapi: strapi2 }
    );
    await Promise.all([
      validatePendingReleasesLimit(),
      validateUniqueNameForPendingRelease(releaseWithCreatorFields.name)
    ]);
    return strapi2.entityService.create(RELEASE_MODEL_UID, {
      data: releaseWithCreatorFields
    });
  },
  async findOne(id, query = {}) {
    const release2 = await strapi2.entityService.findOne(RELEASE_MODEL_UID, id, {
      ...query
    });
    return release2;
  },
  findPage(query) {
    return strapi2.entityService.findPage(RELEASE_MODEL_UID, {
      ...query,
      populate: {
        actions: {
          // @ts-expect-error Ignore missing properties
          count: true
        }
      }
    });
  },
  async findManyWithContentTypeEntryAttached(contentTypeUid, entryId) {
    const releases = await strapi2.db.query(RELEASE_MODEL_UID).findMany({
      where: {
        actions: {
          target_type: contentTypeUid,
          target_id: entryId
        },
        releasedAt: {
          $null: true
        }
      },
      populate: {
        // Filter the action to get only the content type entry
        actions: {
          where: {
            target_type: contentTypeUid,
            target_id: entryId
          }
        }
      }
    });
    return releases.map((release2) => {
      if (release2.actions?.length) {
        const [actionForEntry] = release2.actions;
        delete release2.actions;
        return {
          ...release2,
          action: actionForEntry
        };
      }
      return release2;
    });
  },
  async findManyWithoutContentTypeEntryAttached(contentTypeUid, entryId) {
    const releasesRelated = await strapi2.db.query(RELEASE_MODEL_UID).findMany({
      where: {
        releasedAt: {
          $null: true
        },
        actions: {
          target_type: contentTypeUid,
          target_id: entryId
        }
      }
    });
    const releases = await strapi2.db.query(RELEASE_MODEL_UID).findMany({
      where: {
        $or: [
          {
            id: {
              $notIn: releasesRelated.map((release2) => release2.id)
            }
          },
          {
            actions: null
          }
        ],
        releasedAt: {
          $null: true
        }
      }
    });
    return releases.map((release2) => {
      if (release2.actions?.length) {
        const [actionForEntry] = release2.actions;
        delete release2.actions;
        return {
          ...release2,
          action: actionForEntry
        };
      }
      return release2;
    });
  },
  async update(id, releaseData, { user }) {
    const releaseWithCreatorFields = await utils.setCreatorFields({ user, isEdition: true })(releaseData);
    const release2 = await strapi2.entityService.findOne(RELEASE_MODEL_UID, id);
    if (!release2) {
      throw new utils.errors.NotFoundError(`No release found for id ${id}`);
    }
    if (release2.releasedAt) {
      throw new utils.errors.ValidationError("Release already published");
    }
    const updatedRelease = await strapi2.entityService.update(RELEASE_MODEL_UID, id, {
      /*
       * The type returned from the entity service: Partial<Input<"plugin::content-releases.release">>
       * is not compatible with the type we are passing here: UpdateRelease.Request['body']
       */
      // @ts-expect-error see above
      data: releaseWithCreatorFields
    });
    return updatedRelease;
  },
  async createAction(releaseId, action) {
    const { validateEntryContentType, validateUniqueEntry } = getService("release-validation", {
      strapi: strapi2
    });
    await Promise.all([
      validateEntryContentType(action.entry.contentType),
      validateUniqueEntry(releaseId, action)
    ]);
    const release2 = await strapi2.entityService.findOne(RELEASE_MODEL_UID, releaseId);
    if (!release2) {
      throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
    }
    if (release2.releasedAt) {
      throw new utils.errors.ValidationError("Release already published");
    }
    const { entry, type } = action;
    return strapi2.entityService.create(RELEASE_ACTION_MODEL_UID, {
      data: {
        type,
        contentType: entry.contentType,
        locale: entry.locale,
        entry: {
          id: entry.id,
          __type: entry.contentType,
          __pivot: { field: "entry" }
        },
        release: releaseId
      },
      populate: { release: { fields: ["id"] }, entry: { fields: ["id"] } }
    });
  },
  async findActions(releaseId, query) {
    const release2 = await strapi2.entityService.findOne(RELEASE_MODEL_UID, releaseId, {
      fields: ["id"]
    });
    if (!release2) {
      throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
    }
    return strapi2.entityService.findPage(RELEASE_ACTION_MODEL_UID, {
      ...query,
      populate: {
        entry: {
          populate: "*"
        }
      },
      filters: {
        release: releaseId
      }
    });
  },
  async countActions(query) {
    return strapi2.entityService.count(RELEASE_ACTION_MODEL_UID, query);
  },
  async groupActions(actions, groupBy) {
    const contentTypeUids = actions.reduce((acc, action) => {
      if (!acc.includes(action.contentType)) {
        acc.push(action.contentType);
      }
      return acc;
    }, []);
    const allReleaseContentTypesDictionary = await this.getContentTypesDataForActions(
      contentTypeUids
    );
    const allLocalesDictionary = await this.getLocalesDataForActions();
    const formattedData = actions.map((action) => {
      const { mainField, displayName } = allReleaseContentTypesDictionary[action.contentType];
      return {
        ...action,
        locale: action.locale ? allLocalesDictionary[action.locale] : null,
        contentType: {
          displayName,
          mainFieldValue: action.entry[mainField],
          uid: action.contentType
        }
      };
    });
    const groupName = getGroupName(groupBy);
    return ___default.default.groupBy(groupName)(formattedData);
  },
  async getLocalesDataForActions() {
    if (!strapi2.plugin("i18n")) {
      return {};
    }
    const allLocales = await strapi2.plugin("i18n").service("locales").find() || [];
    return allLocales.reduce((acc, locale) => {
      acc[locale.code] = { name: locale.name, code: locale.code };
      return acc;
    }, {});
  },
  async getContentTypesDataForActions(contentTypesUids) {
    const contentManagerContentTypeService = strapi2.plugin("content-manager").service("content-types");
    const contentTypesData = {};
    for (const contentTypeUid of contentTypesUids) {
      const contentTypeConfig = await contentManagerContentTypeService.findConfiguration({
        uid: contentTypeUid
      });
      contentTypesData[contentTypeUid] = {
        mainField: contentTypeConfig.settings.mainField,
        displayName: strapi2.getModel(contentTypeUid).info.displayName
      };
    }
    return contentTypesData;
  },
  getContentTypeModelsFromActions(actions) {
    const contentTypeUids = actions.reduce((acc, action) => {
      if (!acc.includes(action.contentType)) {
        acc.push(action.contentType);
      }
      return acc;
    }, []);
    const contentTypeModelsMap = contentTypeUids.reduce(
      (acc, contentTypeUid) => {
        acc[contentTypeUid] = strapi2.getModel(contentTypeUid);
        return acc;
      },
      {}
    );
    return contentTypeModelsMap;
  },
  async getAllComponents() {
    const contentManagerComponentsService = strapi2.plugin("content-manager").service("components");
    const components = await contentManagerComponentsService.findAllComponents();
    const componentsMap = components.reduce(
      (acc, component) => {
        acc[component.uid] = component;
        return acc;
      },
      {}
    );
    return componentsMap;
  },
  async delete(releaseId) {
    const release2 = await strapi2.entityService.findOne(RELEASE_MODEL_UID, releaseId, {
      populate: {
        actions: {
          fields: ["id"]
        }
      }
    });
    if (!release2) {
      throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
    }
    if (release2.releasedAt) {
      throw new utils.errors.ValidationError("Release already published");
    }
    await strapi2.db.transaction(async () => {
      await strapi2.db.query(RELEASE_ACTION_MODEL_UID).deleteMany({
        where: {
          id: {
            $in: release2.actions.map((action) => action.id)
          }
        }
      });
      await strapi2.entityService.delete(RELEASE_MODEL_UID, releaseId);
    });
    return release2;
  },
  async publish(releaseId) {
    const releaseWithPopulatedActionEntries = await strapi2.entityService.findOne(
      RELEASE_MODEL_UID,
      releaseId,
      {
        populate: {
          actions: {
            populate: {
              entry: {
                fields: ["id"]
              }
            }
          }
        }
      }
    );
    if (!releaseWithPopulatedActionEntries) {
      throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
    }
    if (releaseWithPopulatedActionEntries.releasedAt) {
      throw new utils.errors.ValidationError("Release already published");
    }
    if (releaseWithPopulatedActionEntries.actions.length === 0) {
      throw new utils.errors.ValidationError("No entries to publish");
    }
    const actions = {};
    for (const action of releaseWithPopulatedActionEntries.actions) {
      const contentTypeUid = action.contentType;
      if (!actions[contentTypeUid]) {
        actions[contentTypeUid] = {
          entriestoPublishIds: [],
          entriesToUnpublishIds: []
        };
      }
      if (action.type === "publish") {
        actions[contentTypeUid].entriestoPublishIds.push(action.entry.id);
      } else {
        actions[contentTypeUid].entriesToUnpublishIds.push(action.entry.id);
      }
    }
    const entityManagerService = strapi2.plugin("content-manager").service("entity-manager");
    const populateBuilderService = strapi2.plugin("content-manager").service("populate-builder");
    await strapi2.db.transaction(async () => {
      for (const contentTypeUid of Object.keys(actions)) {
        const populate = await populateBuilderService(contentTypeUid).populateDeep(Infinity).build();
        const { entriestoPublishIds, entriesToUnpublishIds } = actions[contentTypeUid];
        const entriesToPublish = await strapi2.entityService.findMany(
          contentTypeUid,
          {
            filters: {
              id: {
                $in: entriestoPublishIds
              }
            },
            populate
          }
        );
        const entriesToUnpublish = await strapi2.entityService.findMany(
          contentTypeUid,
          {
            filters: {
              id: {
                $in: entriesToUnpublishIds
              }
            },
            populate
          }
        );
        if (entriesToPublish.length > 0) {
          await entityManagerService.publishMany(entriesToPublish, contentTypeUid);
        }
        if (entriesToUnpublish.length > 0) {
          await entityManagerService.unpublishMany(entriesToUnpublish, contentTypeUid);
        }
      }
    });
    const release2 = await strapi2.entityService.update(RELEASE_MODEL_UID, releaseId, {
      data: {
        /*
         * The type returned from the entity service: Partial<Input<"plugin::content-releases.release">> looks like it's wrong
         */
        // @ts-expect-error see above
        releasedAt: /* @__PURE__ */ new Date()
      }
    });
    return release2;
  },
  async updateAction(actionId, releaseId, update) {
    const updatedAction = await strapi2.db.query(RELEASE_ACTION_MODEL_UID).update({
      where: {
        id: actionId,
        release: {
          id: releaseId,
          releasedAt: {
            $null: true
          }
        }
      },
      data: update
    });
    if (!updatedAction) {
      throw new utils.errors.NotFoundError(
        `Action with id ${actionId} not found in release with id ${releaseId} or it is already published`
      );
    }
    return updatedAction;
  },
  async deleteAction(actionId, releaseId) {
    const deletedAction = await strapi2.db.query(RELEASE_ACTION_MODEL_UID).delete({
      where: {
        id: actionId,
        release: {
          id: releaseId,
          releasedAt: {
            $null: true
          }
        }
      }
    });
    if (!deletedAction) {
      throw new utils.errors.NotFoundError(
        `Action with id ${actionId} not found in release with id ${releaseId} or it is already published`
      );
    }
    return deletedAction;
  }
});
const createReleaseValidationService = ({ strapi: strapi2 }) => ({
  async validateUniqueEntry(releaseId, releaseActionArgs) {
    const release2 = await strapi2.entityService.findOne(RELEASE_MODEL_UID, releaseId, {
      populate: { actions: { populate: { entry: { fields: ["id"] } } } }
    });
    if (!release2) {
      throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
    }
    const isEntryInRelease = release2.actions.some(
      (action) => Number(action.entry.id) === Number(releaseActionArgs.entry.id) && action.contentType === releaseActionArgs.entry.contentType
    );
    if (isEntryInRelease) {
      throw new utils.errors.ValidationError(
        `Entry with id ${releaseActionArgs.entry.id} and contentType ${releaseActionArgs.entry.contentType} already exists in release with id ${releaseId}`
      );
    }
  },
  validateEntryContentType(contentTypeUid) {
    const contentType = strapi2.contentType(contentTypeUid);
    if (!contentType) {
      throw new utils.errors.NotFoundError(`No content type found for uid ${contentTypeUid}`);
    }
    if (!contentType.options?.draftAndPublish) {
      throw new utils.errors.ValidationError(
        `Content type with uid ${contentTypeUid} does not have draftAndPublish enabled`
      );
    }
  },
  async validatePendingReleasesLimit() {
    const maximumPendingReleases = (
      // @ts-expect-error - options is not typed into features
      EE__default.default.features.get("cms-content-releases")?.options?.maximumReleases || 3
    );
    const [, pendingReleasesCount] = await strapi2.db.query(RELEASE_MODEL_UID).findWithCount({
      filters: {
        releasedAt: {
          $null: true
        }
      }
    });
    if (pendingReleasesCount >= maximumPendingReleases) {
      throw new utils.errors.ValidationError("You have reached the maximum number of pending releases");
    }
  },
  async validateUniqueNameForPendingRelease(name) {
    const pendingReleases = await strapi2.entityService.findMany(RELEASE_MODEL_UID, {
      filters: {
        releasedAt: {
          $null: true
        },
        name
      }
    });
    const isNameUnique = pendingReleases.length === 0;
    if (!isNameUnique) {
      throw new utils.errors.ValidationError(`Release with name ${name} already exists`);
    }
  }
});
const services = {
  release: createReleaseService,
  "release-validation": createReleaseValidationService
};
const RELEASE_SCHEMA = yup__namespace.object().shape({
  name: yup__namespace.string().trim().required()
}).required().noUnknown();
const validateRelease = utils.validateYupSchema(RELEASE_SCHEMA);
const releaseController = {
  async findMany(ctx) {
    const permissionsManager = strapi.admin.services.permission.createPermissionsManager({
      ability: ctx.state.userAbility,
      model: RELEASE_MODEL_UID
    });
    await permissionsManager.validateQuery(ctx.query);
    const releaseService = getService("release", { strapi });
    const isFindManyForContentTypeEntry = Boolean(ctx.query?.contentTypeUid && ctx.query?.entryId);
    if (isFindManyForContentTypeEntry) {
      const query = await permissionsManager.sanitizeQuery(ctx.query);
      const contentTypeUid = query.contentTypeUid;
      const entryId = query.entryId;
      const hasEntryAttached = typeof query.hasEntryAttached === "string" ? JSON.parse(query.hasEntryAttached) : false;
      const data = hasEntryAttached ? await releaseService.findManyWithContentTypeEntryAttached(contentTypeUid, entryId) : await releaseService.findManyWithoutContentTypeEntryAttached(contentTypeUid, entryId);
      ctx.body = { data };
    } else {
      const query = await permissionsManager.sanitizeQuery(ctx.query);
      const { results, pagination } = await releaseService.findPage(query);
      const data = results.map((release2) => {
        const { actions, ...releaseData } = release2;
        return {
          ...releaseData,
          actions: {
            meta: {
              count: actions.count
            }
          }
        };
      });
      ctx.body = { data, meta: { pagination } };
    }
  },
  async findOne(ctx) {
    const id = ctx.params.id;
    const releaseService = getService("release", { strapi });
    const release2 = await releaseService.findOne(id, { populate: ["createdBy"] });
    const permissionsManager = strapi.admin.services.permission.createPermissionsManager({
      ability: ctx.state.userAbility,
      model: RELEASE_MODEL_UID
    });
    const sanitizedRelease = await permissionsManager.sanitizeOutput(release2);
    const count = await releaseService.countActions({
      filters: {
        release: id
      }
    });
    if (!release2) {
      throw new utils.errors.NotFoundError(`Release not found for id: ${id}`);
    }
    const data = {
      ...sanitizedRelease,
      actions: {
        meta: {
          count
        }
      }
    };
    ctx.body = { data };
  },
  async create(ctx) {
    const user = ctx.state.user;
    const releaseArgs = ctx.request.body;
    await validateRelease(releaseArgs);
    const releaseService = getService("release", { strapi });
    const release2 = await releaseService.create(releaseArgs, { user });
    const permissionsManager = strapi.admin.services.permission.createPermissionsManager({
      ability: ctx.state.userAbility,
      model: RELEASE_MODEL_UID
    });
    ctx.body = {
      data: await permissionsManager.sanitizeOutput(release2)
    };
  },
  async update(ctx) {
    const user = ctx.state.user;
    const releaseArgs = ctx.request.body;
    const id = ctx.params.id;
    await validateRelease(releaseArgs);
    const releaseService = getService("release", { strapi });
    const release2 = await releaseService.update(id, releaseArgs, { user });
    const permissionsManager = strapi.admin.services.permission.createPermissionsManager({
      ability: ctx.state.userAbility,
      model: RELEASE_MODEL_UID
    });
    ctx.body = {
      data: await permissionsManager.sanitizeOutput(release2)
    };
  },
  async delete(ctx) {
    const id = ctx.params.id;
    const releaseService = getService("release", { strapi });
    const release2 = await releaseService.delete(id);
    ctx.body = {
      data: release2
    };
  },
  async publish(ctx) {
    const user = ctx.state.user;
    const id = ctx.params.id;
    const releaseService = getService("release", { strapi });
    const release2 = await releaseService.publish(id, { user });
    ctx.body = {
      data: release2
    };
  }
};
const RELEASE_ACTION_SCHEMA = utils.yup.object().shape({
  entry: utils.yup.object().shape({
    id: utils.yup.strapiID().required(),
    contentType: utils.yup.string().required()
  }).required(),
  type: utils.yup.string().oneOf(["publish", "unpublish"]).required()
});
const RELEASE_ACTION_UPDATE_SCHEMA = utils.yup.object().shape({
  type: utils.yup.string().oneOf(["publish", "unpublish"]).required()
});
const validateReleaseAction = utils.validateYupSchema(RELEASE_ACTION_SCHEMA);
const validateReleaseActionUpdateSchema = utils.validateYupSchema(RELEASE_ACTION_UPDATE_SCHEMA);
const releaseActionController = {
  async create(ctx) {
    const releaseId = ctx.params.releaseId;
    const releaseActionArgs = ctx.request.body;
    await validateReleaseAction(releaseActionArgs);
    const releaseService = getService("release", { strapi });
    const releaseAction2 = await releaseService.createAction(releaseId, releaseActionArgs);
    ctx.body = {
      data: releaseAction2
    };
  },
  async findMany(ctx) {
    const releaseId = ctx.params.releaseId;
    const permissionsManager = strapi.admin.services.permission.createPermissionsManager({
      ability: ctx.state.userAbility,
      model: RELEASE_ACTION_MODEL_UID
    });
    const query = await permissionsManager.sanitizeQuery(ctx.query);
    const releaseService = getService("release", { strapi });
    const { results, pagination } = await releaseService.findActions(releaseId, {
      sort: query.groupBy === "action" ? "type" : query.groupBy,
      ...query
    });
    const contentTypeOutputSanitizers = results.reduce((acc, action) => {
      if (acc[action.contentType]) {
        return acc;
      }
      const contentTypePermissionsManager = strapi.admin.services.permission.createPermissionsManager({
        ability: ctx.state.userAbility,
        model: action.contentType
      });
      acc[action.contentType] = contentTypePermissionsManager.sanitizeOutput;
      return acc;
    }, {});
    const sanitizedResults = await utils.mapAsync(results, async (action) => ({
      ...action,
      entry: await contentTypeOutputSanitizers[action.contentType](action.entry)
    }));
    const groupedData = await releaseService.groupActions(sanitizedResults, query.groupBy);
    const contentTypes2 = releaseService.getContentTypeModelsFromActions(results);
    const components = await releaseService.getAllComponents();
    ctx.body = {
      data: groupedData,
      meta: {
        pagination,
        contentTypes: contentTypes2,
        components
      }
    };
  },
  async update(ctx) {
    const actionId = ctx.params.actionId;
    const releaseId = ctx.params.releaseId;
    const releaseActionUpdateArgs = ctx.request.body;
    await validateReleaseActionUpdateSchema(releaseActionUpdateArgs);
    const releaseService = getService("release", { strapi });
    const updatedAction = await releaseService.updateAction(
      actionId,
      releaseId,
      releaseActionUpdateArgs
    );
    ctx.body = {
      data: updatedAction
    };
  },
  async delete(ctx) {
    const actionId = ctx.params.actionId;
    const releaseId = ctx.params.releaseId;
    const releaseService = getService("release", { strapi });
    const deletedReleaseAction = await releaseService.deleteAction(actionId, releaseId);
    ctx.body = {
      data: deletedReleaseAction
    };
  }
};
const controllers = { release: releaseController, "release-action": releaseActionController };
const release = {
  type: "admin",
  routes: [
    {
      method: "POST",
      path: "/",
      handler: "release.create",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.create"]
            }
          }
        ]
      }
    },
    {
      method: "GET",
      path: "/",
      handler: "release.findMany",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.read"]
            }
          }
        ]
      }
    },
    {
      method: "GET",
      path: "/:id",
      handler: "release.findOne",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.read"]
            }
          }
        ]
      }
    },
    {
      method: "PUT",
      path: "/:id",
      handler: "release.update",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.update"]
            }
          }
        ]
      }
    },
    {
      method: "DELETE",
      path: "/:id",
      handler: "release.delete",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.delete"]
            }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/:id/publish",
      handler: "release.publish",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.publish"]
            }
          }
        ]
      }
    }
  ]
};
const releaseAction = {
  type: "admin",
  routes: [
    {
      method: "POST",
      path: "/:releaseId/actions",
      handler: "release-action.create",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.create-action"]
            }
          }
        ]
      }
    },
    {
      method: "GET",
      path: "/:releaseId/actions",
      handler: "release-action.findMany",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.read"]
            }
          }
        ]
      }
    },
    {
      method: "PUT",
      path: "/:releaseId/actions/:actionId",
      handler: "release-action.update",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.update"]
            }
          }
        ]
      }
    },
    {
      method: "DELETE",
      path: "/:releaseId/actions/:actionId",
      handler: "release-action.delete",
      config: {
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "admin::hasPermissions",
            config: {
              actions: ["plugin::content-releases.delete-action"]
            }
          }
        ]
      }
    }
  ]
};
const routes = {
  release,
  "release-action": releaseAction
};
const { features } = require("@strapi/strapi/dist/utils/ee");
const getPlugin = () => {
  if (features.isEnabled("cms-content-releases")) {
    return {
      register,
      bootstrap,
      contentTypes,
      services,
      controllers,
      routes
    };
  }
  return {
    contentTypes
  };
};
const index = getPlugin();
module.exports = index;
//# sourceMappingURL=index.js.map
